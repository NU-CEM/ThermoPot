{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>\u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f This repository is still in development, and some functionality is untested. Use with caution, or wait until we fully test it! \u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f</p> <p>ThermoPot is used for ab-initio thermodynamic modelling of material formation and decomposition.</p> <ul> <li>\ud83d\udcda The documentation is here. </li> <li>\ud83d\udd04 This code is made available under the GNU General Public Licence (GPL) v3. See the LICENSE file for the full text.</li> <li>\ud83d\udd8a If you use this package for your research please cite accordingly.</li> </ul> <p>This work adapts and extends a previous repository developed by Adam Jackson: Thermodynamic model of CZTS. </p>"},{"location":"#features","title":"Features","text":"<p>ThermoPot calculates temperature and pressure dependent thermodynamic potentials using first-principles data. Thermopot can:</p> <ul> <li>calculate the internal energy, enthalpy and Gibbs free energy at a given temperature and pressure</li> <li>calculate the change in energy/enthalpy for a given reaction</li> <li>work with solid or gases</li> <li>plot potentials as a function of T and P</li> <li>predict thermodynamic stability as a function of T and P</li> <li>Parse DFT data from an FHI-aims output file and lattice dynamics data from Phonopy output</li> <li>Parse experimental data from the NIST-JANAF thermochemical tables.</li> </ul>"},{"location":"#supported-software","title":"Supported software","text":"<p>ThermoPot is compatible with a range of materials modelling packages as DFT energies and thermal properties data can be provided by the user. ThermoPot also supports parsing of FHI-aims output files, phonopy output and NIST-JANAF thermochemical data tables.</p>"},{"location":"#related-software","title":"Related software","text":"<p>There are other codes that can calculate thermodynamic potentials and phase diagrams. The best code depends on your use case: - Surfinpy generates phase diagrams for bulk and surface systems.  - pycalphad uses the CALPHAD method to generate phase diagram and predict thermodynamic properties. - thermo uses cubic equations of state to generate phase diagrams for liquids and gases.</p>"},{"location":"api/","title":"API documentation","text":"<p>Module to parse and store data from electronic structure calculations. Contains the parent class Calculation to store data from a variety of sources. Contains the child class AimsCalculation to read and store data from a FHI-aims calculation.</p> <p>Module contains the classes Sulfur_model, Solid and IdealGas to store basic material data. Each class provides methods for calculating various thermodynamic properties.</p>"},{"location":"api/#thermopot.calculations.AimsCalculation","title":"<code>AimsCalculation</code>","text":"<p>             Bases: <code>Calculation</code></p> <p>Class for parsing and storing data from a FHI-AIMS total energy calculation.</p> <p>Example:</p> <p>BaS_calc = AimsCalculation(\"./aims_output/output.aims\")</p> <p>Attributes:</p> <pre><code>volume (float): volume of the periodic unit cell in Angstrom^3\nfilepath (str): path to the calculation output files\nenergy (float): DFT total energy in eV\nxc (str): XC functional used to calculate the total energy\nNAtoms (int): number of atoms in the periodic unit cell\n</code></pre> Source code in <code>thermopot/calculations.py</code> <pre><code>class AimsCalculation(Calculation):\n    \"\"\"Class for parsing and storing data from a FHI-AIMS total energy calculation.\n\n    Example:\n\n       BaS_calc = AimsCalculation(\"./aims_output/output.aims\")\n\n    Attributes:\n\n        volume (float): volume of the periodic unit cell in Angstrom^3\n        filepath (str): path to the calculation output files\n        energy (float): DFT total energy in eV\n        xc (str): XC functional used to calculate the total energy\n        NAtoms (int): number of atoms in the periodic unit cell\n    \"\"\"\n\n    def __init__(self, filepath=\"./calculation.out\", gas=False):\n        \"\"\"\n        Args:\n\n            filepath (str): path to the calculation output files\n            gas (bool): True if gas species, False otherwise\n\n        Note:\n\n            If gas is True then volume is None\n        \"\"\"\n        super().__init__()\n        self.filepath = filepath\n        if not gas:\n            self.volume = self.get_volume()\n        self.energy = self.get_energy()\n        self.xc = self.get_xc()\n        self.NAtoms = self.get_NAtoms()\n\n    def get_volume(self):\n        \"\"\"\n        Returns:\n\n            (float): volume of the periodic unit cell in Angstrom^3\n        \"\"\"\n        with open(self.filepath) as contents:\n            return float(\n                re.findall(\"Unit cell volume\\s+:\\s*(.*)\\sA\", contents.read())[-1]\n            )\n\n    def get_energy(self):\n        \"\"\"\n        Returns:\n\n            (float): DFT total energy in eV\n        \"\"\"\n        with open(self.filepath) as contents:\n            return float(\n                re.findall(\n                    \"Total energy of the DFT[^0-9]+(-\\d*\\.?\\d*) eV\", contents.read()\n                )[-1]\n            )\n\n    def get_xc(self):\n        \"\"\"\n        Returns:\n\n            (str): XC functional used to calculate the total energy\n        \"\"\"\n        with open(self.filepath) as contents:\n            return re.findall(\"xc               (\\S+)\", contents.read())[0]\n\n    def get_NAtoms(self):\n        \"\"\"\n        Returns:\n\n            (int): number of atoms in the periodic unit cell\n        \"\"\"\n        with open(self.filepath) as contents:\n            return int(\n                re.findall(\"Number of atoms\\s +:\\s + (\\S+)\", contents.read())[-1]\n            )\n</code></pre>"},{"location":"api/#thermopot.calculations.AimsCalculation.__init__","title":"<code>__init__(filepath='./calculation.out', gas=False)</code>","text":"<p>Args:</p> <pre><code>filepath (str): path to the calculation output files\ngas (bool): True if gas species, False otherwise\n</code></pre> <p>Note:</p> <pre><code>If gas is True then volume is None\n</code></pre> Source code in <code>thermopot/calculations.py</code> <pre><code>def __init__(self, filepath=\"./calculation.out\", gas=False):\n    \"\"\"\n    Args:\n\n        filepath (str): path to the calculation output files\n        gas (bool): True if gas species, False otherwise\n\n    Note:\n\n        If gas is True then volume is None\n    \"\"\"\n    super().__init__()\n    self.filepath = filepath\n    if not gas:\n        self.volume = self.get_volume()\n    self.energy = self.get_energy()\n    self.xc = self.get_xc()\n    self.NAtoms = self.get_NAtoms()\n</code></pre>"},{"location":"api/#thermopot.calculations.AimsCalculation.get_NAtoms","title":"<code>get_NAtoms()</code>","text":"<p>Returns:</p> <pre><code>(int): number of atoms in the periodic unit cell\n</code></pre> Source code in <code>thermopot/calculations.py</code> <pre><code>def get_NAtoms(self):\n    \"\"\"\n    Returns:\n\n        (int): number of atoms in the periodic unit cell\n    \"\"\"\n    with open(self.filepath) as contents:\n        return int(\n            re.findall(\"Number of atoms\\s +:\\s + (\\S+)\", contents.read())[-1]\n        )\n</code></pre>"},{"location":"api/#thermopot.calculations.AimsCalculation.get_energy","title":"<code>get_energy()</code>","text":"<p>Returns:</p> <pre><code>(float): DFT total energy in eV\n</code></pre> Source code in <code>thermopot/calculations.py</code> <pre><code>def get_energy(self):\n    \"\"\"\n    Returns:\n\n        (float): DFT total energy in eV\n    \"\"\"\n    with open(self.filepath) as contents:\n        return float(\n            re.findall(\n                \"Total energy of the DFT[^0-9]+(-\\d*\\.?\\d*) eV\", contents.read()\n            )[-1]\n        )\n</code></pre>"},{"location":"api/#thermopot.calculations.AimsCalculation.get_volume","title":"<code>get_volume()</code>","text":"<p>Returns:</p> <pre><code>(float): volume of the periodic unit cell in Angstrom^3\n</code></pre> Source code in <code>thermopot/calculations.py</code> <pre><code>def get_volume(self):\n    \"\"\"\n    Returns:\n\n        (float): volume of the periodic unit cell in Angstrom^3\n    \"\"\"\n    with open(self.filepath) as contents:\n        return float(\n            re.findall(\"Unit cell volume\\s+:\\s*(.*)\\sA\", contents.read())[-1]\n        )\n</code></pre>"},{"location":"api/#thermopot.calculations.AimsCalculation.get_xc","title":"<code>get_xc()</code>","text":"<p>Returns:</p> <pre><code>(str): XC functional used to calculate the total energy\n</code></pre> Source code in <code>thermopot/calculations.py</code> <pre><code>def get_xc(self):\n    \"\"\"\n    Returns:\n\n        (str): XC functional used to calculate the total energy\n    \"\"\"\n    with open(self.filepath) as contents:\n        return re.findall(\"xc               (\\S+)\", contents.read())[0]\n</code></pre>"},{"location":"api/#thermopot.calculations.Calculation","title":"<code>Calculation</code>","text":"<p>Parent class for parsing and storing data from electronic structure calculations.</p> <p>Example:</p> <pre><code>BaS_calc = Calculation(volume=63.2552, energy=-235926.586148547, xc='pbesol', NAtoms=2)\n</code></pre> <p>Attributes:</p> <pre><code>volume (float): volume of the periodic unit cell in Angstrom^3\nfilepath (str): path to the calculation output files\nenergy (float): DFT total energy in eV\nxc (str): XC functional used to calculate the total energy\nNAtoms (int): number of atoms in the periodic unit cell\n</code></pre> <p>Note:</p> <pre><code>If gas is True then no volume attribute is required.\n</code></pre> Source code in <code>thermopot/calculations.py</code> <pre><code>class Calculation:\n    \"\"\"\n    Parent class for parsing and storing data from electronic structure calculations.\n\n    Example:\n\n        BaS_calc = Calculation(volume=63.2552, energy=-235926.586148547, xc='pbesol', NAtoms=2)\n\n    Attributes:\n\n        volume (float): volume of the periodic unit cell in Angstrom^3\n        filepath (str): path to the calculation output files\n        energy (float): DFT total energy in eV\n        xc (str): XC functional used to calculate the total energy\n        NAtoms (int): number of atoms in the periodic unit cell\n\n    Note:\n\n        If gas is True then no volume attribute is required.\n    \"\"\"\n\n    def __init__(\n        self, energy=None, xc=None, NAtoms=None, volume=None, filepath=None, gas=False\n    ):\n        \"\"\"\n        Note:\n\n            All attributes are None until set by derived classes or specified by user.\n\n        Args:\n\n            volume (float): volume of the periodic unit cell in Angstrom^3\n            filepath (str, optional): path to the calculation output files\n            energy (float): DFT total energy in eV\n            xc (str): XC functional used to calculate the total energy\n            NAtoms (int): number of atoms in the periodic unit cell\n            gas (bool): True if gas species, False otherwise\n\n        Note:\n\n            If gas is True then volume is None\n        \"\"\"\n        if not gas:\n            self.volume = volume\n        self.filepath = filepath\n        self.energy = energy\n        self.xc = xc\n        self.NAtoms = NAtoms\n\n        # self.check_attributes()\n\n    def check_attributes(self):\n        \"\"\"Check that the Calculation class attributes make basic sense.\"\"\"\n\n        assert (\n            type(self.filepath) == str or self.filepath is None\n        ), \"filepath must be a string\"\n        assert type(self.energy) == float, \"energy must be a float\"\n        assert type(self.xc) == str, \"xc must be a string\"\n        assert (\n            type(self.NAtoms) == int\n        ) and self.NAtoms &gt;= 1, \"NAtoms must be an integer &gt;= 1\"\n        assert (\n            type(self.volume) == float\n        ) and self.volume &gt; 0, \"volume must be a float &gt; 0\"\n</code></pre>"},{"location":"api/#thermopot.calculations.Calculation.__init__","title":"<code>__init__(energy=None, xc=None, NAtoms=None, volume=None, filepath=None, gas=False)</code>","text":"<p>Note:</p> <pre><code>All attributes are None until set by derived classes or specified by user.\n</code></pre> <p>Args:</p> <pre><code>volume (float): volume of the periodic unit cell in Angstrom^3\nfilepath (str, optional): path to the calculation output files\nenergy (float): DFT total energy in eV\nxc (str): XC functional used to calculate the total energy\nNAtoms (int): number of atoms in the periodic unit cell\ngas (bool): True if gas species, False otherwise\n</code></pre> <p>Note:</p> <pre><code>If gas is True then volume is None\n</code></pre> Source code in <code>thermopot/calculations.py</code> <pre><code>def __init__(\n    self, energy=None, xc=None, NAtoms=None, volume=None, filepath=None, gas=False\n):\n    \"\"\"\n    Note:\n\n        All attributes are None until set by derived classes or specified by user.\n\n    Args:\n\n        volume (float): volume of the periodic unit cell in Angstrom^3\n        filepath (str, optional): path to the calculation output files\n        energy (float): DFT total energy in eV\n        xc (str): XC functional used to calculate the total energy\n        NAtoms (int): number of atoms in the periodic unit cell\n        gas (bool): True if gas species, False otherwise\n\n    Note:\n\n        If gas is True then volume is None\n    \"\"\"\n    if not gas:\n        self.volume = volume\n    self.filepath = filepath\n    self.energy = energy\n    self.xc = xc\n    self.NAtoms = NAtoms\n</code></pre>"},{"location":"api/#thermopot.calculations.Calculation.check_attributes","title":"<code>check_attributes()</code>","text":"<p>Check that the Calculation class attributes make basic sense.</p> Source code in <code>thermopot/calculations.py</code> <pre><code>def check_attributes(self):\n    \"\"\"Check that the Calculation class attributes make basic sense.\"\"\"\n\n    assert (\n        type(self.filepath) == str or self.filepath is None\n    ), \"filepath must be a string\"\n    assert type(self.energy) == float, \"energy must be a float\"\n    assert type(self.xc) == str, \"xc must be a string\"\n    assert (\n        type(self.NAtoms) == int\n    ) and self.NAtoms &gt;= 1, \"NAtoms must be an integer &gt;= 1\"\n    assert (\n        type(self.volume) == float\n    ) and self.volume &gt; 0, \"volume must be a float &gt; 0\"\n</code></pre>"},{"location":"api/#thermopot.materials.IdealGas","title":"<code>IdealGas</code>","text":"<p>             Bases: <code>Material</code></p> <p>Class for ideal gas properties.</p> <p>Example:</p> <pre><code>S2_gas = materials.IdealGas(\"S2\", {\"S\":2}, \"./thermo_data/S2\",calculation=S2_gas_calc)\n</code></pre> <p>Attributes:</p> <p>name (str): Identifying string    stoichiometry (dict): relates element to the number of atoms in a single formula unit    thermo_dile (str): path to the thermodynamics data    calculation (thermopot.calculation.Calculation, optional): instance of the thermopot.calculation.Calculation class    energies (dict, optional): relates xc functional to DFT total energy in eV    zpe_pbesol (float, optional): zero point energy calculated using the pbesol XC-functional    zpe_hse06 (float, optional): zero point energy calculated using the hse06 XC-functional    zpe_lit (float, optional): zero point energy calculated using literature values</p> <p>Note:</p> <pre><code>Ideal gas law PV=nRT is applied: specifically (dH/dP) at const. T = 0 and int(mu)^P2_P1 dP = kTln(P2/P1).\nEnthalpy has no P dependence as volume is not restricted / expansion step is defined as isothermal\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>class IdealGas(Material):\n    \"\"\"\n    Class for ideal gas properties.\n\n    Example:\n\n        S2_gas = materials.IdealGas(\"S2\", {\"S\":2}, \"./thermo_data/S2\",calculation=S2_gas_calc)\n\n    Attributes:\n\n       name (str): Identifying string\n       stoichiometry (dict): relates element to the number of atoms in a single formula unit\n       thermo_dile (str): path to the thermodynamics data\n       calculation (thermopot.calculation.Calculation, optional): instance of the thermopot.calculation.Calculation class\n       energies (dict, optional): relates xc functional to DFT total energy in eV\n       zpe_pbesol (float, optional): zero point energy calculated using the pbesol XC-functional\n       zpe_hse06 (float, optional): zero point energy calculated using the hse06 XC-functional\n       zpe_lit (float, optional): zero point energy calculated using literature values\n\n    Note:\n\n        Ideal gas law PV=nRT is applied: specifically (dH/dP) at const. T = 0 and int(mu)^P2_P1 dP = kTln(P2/P1).\n        Enthalpy has no P dependence as volume is not restricted / expansion step is defined as isothermal\n    \"\"\"\n\n    def __init__(\n        self,\n        name,\n        stoichiometry,\n        thermo_file,\n        calculation=False,\n        energies=False,\n        zpe_pbesol=0,\n        zpe_hse06=0,\n        zpe_lit=0,\n    ):\n        \"\"\"\n        Args:\n\n        name (str): Identifying string\n        stoichiometry (dict): relates element to the number of atoms in a single formula unit\n        thermo_dile (str): path to the thermodynamics data\n        calculation (thermopot.calculation.Calculation, optional): instance of the thermopot.calculation.Calculation class\n        energies (dict, optional): relates xc functional to DFT total energy in eV\n        zpe_pbesol (float, optional): zero point energy calculated using the pbesol XC-functional\n        zpe_hse06 (float, optional): zero point energy calculated using the hse06 XC-functional\n        zpe_lit (float, optional): zero point energy calculated using literature values\n        \"\"\"\n        if calculation is not False:\n            Material.__init__(\n                self, name, stoichiometry, {calculation.xc: calculation.energy}\n            )\n        else:\n            Material.__init__(self, name, stoichiometry, energies)\n        self.thermo_file = materials_directory + thermo_file\n\n        if zpe_hse06 &gt; 0:\n            self.zpe = zpe_pbesol\n        elif zpe_pbesol &gt; 0:\n            self.zpe = zpe_pbesol\n        elif zpe_lit &gt; 0:\n            self.zpe = zpe_lit\n        else:\n            self.zpe = 0\n\n    def U(self, T, xc=\"pbesol\", units=\"eV\"):\n        \"\"\"\n        Calculates the internal energy of one formula unit of ideal gas.\n\n        Example:\n\n            U = S2_gas.U(300,xc=\"pbesol\",units=\"eV\")\n\n        Args:\n\n            T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n            xc (str, optional): DFT XC functional used to calculate the ground state energy\n            units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n        Returns:\n\n            U (float/ndarray): 1D Numpy array (with the same dimensions as T) containing the internal energies of one formula unit of gas, or a single internal energy float when a single temperature is passed as an argument.\n\n        \"\"\"\n        U_func = interpolate.get_potential_nist_table(self.thermo_file, \"U\")\n        E_dft = self.energies[xc]\n        U_eV = (\n            E_dft\n            + self.zpe\n            + U_func(T)\n            * constants.physical_constants[\"joule-electron volt relationship\"][0]\n            / constants.N_A\n        )\n\n        if units == \"eV\":\n            return U_eV\n\n        elif units == \"J\":\n            return (\n                U_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n            )\n\n        elif units == \"kJ\":\n            return (\n                U_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n                * 0.001\n            )\n\n    def H(self, T, xc=\"pbesol\", units=\"eV\"):\n        \"\"\"\n        Calculates the Enthalpy of one formula unit of ideal gas.\n\n        Examples:\n\n            H = S2_gas.H(300,xc=\"pbesol\",units=\"eV\")\n            H = S2_gas.H(np.linspace(100,700,1000))\n\n        Args:\n\n            T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n            xc (str, optional): DFT XC functional used to calculate the ground state energy\n            units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n        Returns:\n\n            H (float/ndarray):  1D Numpy array (with the same dimensions as T) containing the enthalpy of one formula unit of gas, or a single enthalpy float when a single temperature is passed as an argument.\n        \"\"\"\n        H_func = interpolate.get_potential_nist_table(self.thermo_file, \"H\")\n        E_dft = self.energies[xc]\n        H_eV = (\n            E_dft\n            + self.zpe\n            + H_func(T)\n            * constants.physical_constants[\"joule-electron volt relationship\"][0]\n            / constants.N_A\n        )\n\n        if units == \"eV\":\n            return H_eV\n\n        elif units == \"J\":\n            return (\n                H_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n            )\n\n        elif units == \"kJ\":\n            return (\n                H_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n                * 0.001\n            )\n\n    def mu(self, T, P, xc=\"pbesol\", units=\"eV\"):\n        \"\"\"\n        Calculates the Gibbs Free Energy of one formula unit of ideal gas.\n\n        Examples:\n\n            mu = S2_gas.mu(300,xc=\"pbesol\",units=\"eV\")\n            mu = S2_gas.mu(np.linspace(100,700,1000))\n\n        Args:\n\n            T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n            P (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\n            xc (str, optional): DFT XC functional used to calculate the ground state energy\n            units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n        Note:\n\n            T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case mu is an m x n matrix.\n            Other T, P arrays will result in undefined behaviour.\n\n        Returns:\n\n            mu (float/ndarray): Gibbs Free Energy of one formula unit of ideal gas expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n        \"\"\"\n\n        S_func = interpolate.get_potential_nist_table(self.thermo_file, \"S\")\n        S = (\n            S_func(T)\n            * constants.physical_constants[\"joule-electron volt relationship\"][0]\n            / constants.N_A\n        )\n        H = self.H(T, xc=xc)\n        mu_eV = (\n            H\n            - T * S\n            + constants.physical_constants[\"Boltzmann constant in eV/K\"][0]\n            * T\n            * np.log(P / 1e5)\n        )\n\n        if units == \"eV\":\n            return mu_eV\n\n        elif units == \"J\":\n            return (\n                mu_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n            )\n\n        elif units == \"kJ\":\n            return (\n                mu_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n                * 0.001\n            )\n</code></pre>"},{"location":"api/#thermopot.materials.IdealGas.H","title":"<code>H(T, xc='pbesol', units='eV')</code>","text":"<p>Calculates the Enthalpy of one formula unit of ideal gas.</p> <p>Examples:</p> <pre><code>H = S2_gas.H(300,xc=\"pbesol\",units=\"eV\")\nH = S2_gas.H(np.linspace(100,700,1000))\n</code></pre> <p>Args:</p> <pre><code>T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\nxc (str, optional): DFT XC functional used to calculate the ground state energy\nunits (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n</code></pre> <p>Returns:</p> <pre><code>H (float/ndarray):  1D Numpy array (with the same dimensions as T) containing the enthalpy of one formula unit of gas, or a single enthalpy float when a single temperature is passed as an argument.\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>def H(self, T, xc=\"pbesol\", units=\"eV\"):\n    \"\"\"\n    Calculates the Enthalpy of one formula unit of ideal gas.\n\n    Examples:\n\n        H = S2_gas.H(300,xc=\"pbesol\",units=\"eV\")\n        H = S2_gas.H(np.linspace(100,700,1000))\n\n    Args:\n\n        T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n        xc (str, optional): DFT XC functional used to calculate the ground state energy\n        units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n    Returns:\n\n        H (float/ndarray):  1D Numpy array (with the same dimensions as T) containing the enthalpy of one formula unit of gas, or a single enthalpy float when a single temperature is passed as an argument.\n    \"\"\"\n    H_func = interpolate.get_potential_nist_table(self.thermo_file, \"H\")\n    E_dft = self.energies[xc]\n    H_eV = (\n        E_dft\n        + self.zpe\n        + H_func(T)\n        * constants.physical_constants[\"joule-electron volt relationship\"][0]\n        / constants.N_A\n    )\n\n    if units == \"eV\":\n        return H_eV\n\n    elif units == \"J\":\n        return (\n            H_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n        )\n\n    elif units == \"kJ\":\n        return (\n            H_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n            * 0.001\n        )\n</code></pre>"},{"location":"api/#thermopot.materials.IdealGas.U","title":"<code>U(T, xc='pbesol', units='eV')</code>","text":"<p>Calculates the internal energy of one formula unit of ideal gas.</p> <p>Example:</p> <pre><code>U = S2_gas.U(300,xc=\"pbesol\",units=\"eV\")\n</code></pre> <p>Args:</p> <pre><code>T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\nxc (str, optional): DFT XC functional used to calculate the ground state energy\nunits (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n</code></pre> <p>Returns:</p> <pre><code>U (float/ndarray): 1D Numpy array (with the same dimensions as T) containing the internal energies of one formula unit of gas, or a single internal energy float when a single temperature is passed as an argument.\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>def U(self, T, xc=\"pbesol\", units=\"eV\"):\n    \"\"\"\n    Calculates the internal energy of one formula unit of ideal gas.\n\n    Example:\n\n        U = S2_gas.U(300,xc=\"pbesol\",units=\"eV\")\n\n    Args:\n\n        T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n        xc (str, optional): DFT XC functional used to calculate the ground state energy\n        units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n    Returns:\n\n        U (float/ndarray): 1D Numpy array (with the same dimensions as T) containing the internal energies of one formula unit of gas, or a single internal energy float when a single temperature is passed as an argument.\n\n    \"\"\"\n    U_func = interpolate.get_potential_nist_table(self.thermo_file, \"U\")\n    E_dft = self.energies[xc]\n    U_eV = (\n        E_dft\n        + self.zpe\n        + U_func(T)\n        * constants.physical_constants[\"joule-electron volt relationship\"][0]\n        / constants.N_A\n    )\n\n    if units == \"eV\":\n        return U_eV\n\n    elif units == \"J\":\n        return (\n            U_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n        )\n\n    elif units == \"kJ\":\n        return (\n            U_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n            * 0.001\n        )\n</code></pre>"},{"location":"api/#thermopot.materials.IdealGas.__init__","title":"<code>__init__(name, stoichiometry, thermo_file, calculation=False, energies=False, zpe_pbesol=0, zpe_hse06=0, zpe_lit=0)</code>","text":"<p>Args:</p> <p>name (str): Identifying string stoichiometry (dict): relates element to the number of atoms in a single formula unit thermo_dile (str): path to the thermodynamics data calculation (thermopot.calculation.Calculation, optional): instance of the thermopot.calculation.Calculation class energies (dict, optional): relates xc functional to DFT total energy in eV zpe_pbesol (float, optional): zero point energy calculated using the pbesol XC-functional zpe_hse06 (float, optional): zero point energy calculated using the hse06 XC-functional zpe_lit (float, optional): zero point energy calculated using literature values</p> Source code in <code>thermopot/materials.py</code> <pre><code>def __init__(\n    self,\n    name,\n    stoichiometry,\n    thermo_file,\n    calculation=False,\n    energies=False,\n    zpe_pbesol=0,\n    zpe_hse06=0,\n    zpe_lit=0,\n):\n    \"\"\"\n    Args:\n\n    name (str): Identifying string\n    stoichiometry (dict): relates element to the number of atoms in a single formula unit\n    thermo_dile (str): path to the thermodynamics data\n    calculation (thermopot.calculation.Calculation, optional): instance of the thermopot.calculation.Calculation class\n    energies (dict, optional): relates xc functional to DFT total energy in eV\n    zpe_pbesol (float, optional): zero point energy calculated using the pbesol XC-functional\n    zpe_hse06 (float, optional): zero point energy calculated using the hse06 XC-functional\n    zpe_lit (float, optional): zero point energy calculated using literature values\n    \"\"\"\n    if calculation is not False:\n        Material.__init__(\n            self, name, stoichiometry, {calculation.xc: calculation.energy}\n        )\n    else:\n        Material.__init__(self, name, stoichiometry, energies)\n    self.thermo_file = materials_directory + thermo_file\n\n    if zpe_hse06 &gt; 0:\n        self.zpe = zpe_pbesol\n    elif zpe_pbesol &gt; 0:\n        self.zpe = zpe_pbesol\n    elif zpe_lit &gt; 0:\n        self.zpe = zpe_lit\n    else:\n        self.zpe = 0\n</code></pre>"},{"location":"api/#thermopot.materials.IdealGas.mu","title":"<code>mu(T, P, xc='pbesol', units='eV')</code>","text":"<p>Calculates the Gibbs Free Energy of one formula unit of ideal gas.</p> <p>Examples:</p> <pre><code>mu = S2_gas.mu(300,xc=\"pbesol\",units=\"eV\")\nmu = S2_gas.mu(np.linspace(100,700,1000))\n</code></pre> <p>Args:</p> <pre><code>T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\nP (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\nxc (str, optional): DFT XC functional used to calculate the ground state energy\nunits (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n</code></pre> <p>Note:</p> <pre><code>T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case mu is an m x n matrix.\nOther T, P arrays will result in undefined behaviour.\n</code></pre> <p>Returns:</p> <pre><code>mu (float/ndarray): Gibbs Free Energy of one formula unit of ideal gas expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>def mu(self, T, P, xc=\"pbesol\", units=\"eV\"):\n    \"\"\"\n    Calculates the Gibbs Free Energy of one formula unit of ideal gas.\n\n    Examples:\n\n        mu = S2_gas.mu(300,xc=\"pbesol\",units=\"eV\")\n        mu = S2_gas.mu(np.linspace(100,700,1000))\n\n    Args:\n\n        T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n        P (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\n        xc (str, optional): DFT XC functional used to calculate the ground state energy\n        units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n    Note:\n\n        T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case mu is an m x n matrix.\n        Other T, P arrays will result in undefined behaviour.\n\n    Returns:\n\n        mu (float/ndarray): Gibbs Free Energy of one formula unit of ideal gas expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n    \"\"\"\n\n    S_func = interpolate.get_potential_nist_table(self.thermo_file, \"S\")\n    S = (\n        S_func(T)\n        * constants.physical_constants[\"joule-electron volt relationship\"][0]\n        / constants.N_A\n    )\n    H = self.H(T, xc=xc)\n    mu_eV = (\n        H\n        - T * S\n        + constants.physical_constants[\"Boltzmann constant in eV/K\"][0]\n        * T\n        * np.log(P / 1e5)\n    )\n\n    if units == \"eV\":\n        return mu_eV\n\n    elif units == \"J\":\n        return (\n            mu_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n        )\n\n    elif units == \"kJ\":\n        return (\n            mu_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n            * 0.001\n        )\n</code></pre>"},{"location":"api/#thermopot.materials.Material","title":"<code>Material</code>","text":"<p>             Bases: <code>object</code></p> <p>Parent class for storing materials properties.</p> <p>Attributes:</p> <pre><code>name (str): Identifying string\nstoichiometry (dict): relates element to the number of atoms in a single formula unit\nenergies (dict): relates xc functional to DFT total energy in eV\nN (int): number of atoms per formula unit\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>class Material(object):\n    \"\"\"\n    Parent class for storing materials properties.\n\n    Attributes:\n\n        name (str): Identifying string\n        stoichiometry (dict): relates element to the number of atoms in a single formula unit\n        energies (dict): relates xc functional to DFT total energy in eV\n        N (int): number of atoms per formula unit\n    \"\"\"\n\n    def __init__(self, name, stoichiometry, energies):\n        self.name = name\n        self.stoichiometry = stoichiometry\n        self.energies = energies\n        self.N = sum(self.stoichiometry.values())\n</code></pre>"},{"location":"api/#thermopot.materials.Solid","title":"<code>Solid</code>","text":"<p>             Bases: <code>Material</code></p> <p>Class for solid material data.</p> <p>Note:</p> <pre><code>The material is assumed to be incompressible and without thermal expansion.\n</code></pre> <p>Example:</p> <pre><code>BaS = Solid('BaS',{'Ba':1,'S':1},\"./phonon_data/Ba_S\",calculation=BaS_calc)\n</code></pre> <p>Attributes:</p> <pre><code>name (str): Identifying string\nstoichiometry (dict): relates element to the number of atoms in a single formula unit\nenergies (dict): relates xc functional to DFT total energy in eV\nN (int): number of atoms per formula unit\nfu_cell (int): number of formula units in periodic unit cell\nvolume (float): volume of unit cell in Angstroms^3\nphonon_filepath (str): path to the phonon output data\nNAtoms (int): number of atoms in periodic unit cell\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>class Solid(Material):\n    \"\"\"\n    Class for solid material data.\n\n    Note:\n\n        The material is assumed to be incompressible and without thermal expansion.\n\n    Example:\n\n        BaS = Solid('BaS',{'Ba':1,'S':1},\"./phonon_data/Ba_S\",calculation=BaS_calc)\n\n    Attributes:\n\n        name (str): Identifying string\n        stoichiometry (dict): relates element to the number of atoms in a single formula unit\n        energies (dict): relates xc functional to DFT total energy in eV\n        N (int): number of atoms per formula unit\n        fu_cell (int): number of formula units in periodic unit cell\n        volume (float): volume of unit cell in Angstroms^3\n        phonon_filepath (str): path to the phonon output data\n        NAtoms (int): number of atoms in periodic unit cell\n    \"\"\"\n\n    def __init__(\n        self,\n        name,\n        stoichiometry,\n        phonon_filepath,\n        calculation=False,\n        volume=False,\n        energies=False,\n        NAtoms=1,\n    ):\n        \"\"\"\n        Args:\n\n           name (str): Identifying string\n           stoichiometry (dict): relates element to the number of atoms in a single formula unit\n           phonon_filepath (str): path to the phonon output data\n           calculation (thermopot.calculation.Calculation, optional): instance of the thermopot.calculation.Calculation class\n           volume (float, optional): volume of unit cell in Angstroms^3\n           energies (dict, optional): relates xc functional to DFT total energy in eV\n           NAtoms (int): number of atoms in periodic unit cell\n        \"\"\"\n\n        if calculation is not False:\n            if type(calculation) is not list:\n                Material.__init__(\n                    self, name, stoichiometry, {calculation.xc: calculation.energy}\n                )\n                self.volume = calculation.volume\n                self.NAtoms = calculation.NAtoms\n            else:\n                pass\n\n        else:\n            Material.__init__(self, name, stoichiometry, energies)\n\n            self.NAtoms = NAtoms\n            self.volume = volume\n\n        self.fu_cell = self.NAtoms / self.N\n        self.phonon_filepath = materials_directory + phonon_filepath\n\n    def U(self, T, xc=\"pbesol\", units=\"eV\"):\n        \"\"\"\n        Calculates the internal energy of one formula unit of solid.\n\n        Example:\n\n            U = BaS.U(300,xc=\"pbesol\",units=\"eV\")\n\n        Args:\n\n            T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n            xc (str, optional): DFT XC functional used to calculate the ground state energy\n            units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n        Returns:\n\n            U (float/ndarray): 1D Numpy array (with the same dimensions as T) containing the internal energies of one formula unit of solid, or a single internal energy float when a single temperature is passed as an argument.\n\n        \"\"\"\n        U_func = interpolate.get_potential_aims(self.phonon_filepath, \"U\")\n        E_dft = self.energies[xc]\n\n        U_eV = (E_dft + U_func(T)) / self.fu_cell\n\n        if units == \"eV\":\n            return U_eV\n\n        elif units == \"J\":\n            return (\n                U_eV(T, xc=xc)\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n            )\n\n        elif units == \"kJ\":\n            return (\n                U_eV(T, xc=xc)\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n                * 0.001\n            )\n\n    def H(self, T, P, xc=\"pbesol\", units=\"eV\"):\n        \"\"\"\n        Calculates the Enthalpy (H = U + PV) of one formula unit of solid.\n\n        Examples:\n\n            H = BaS.H(300,1E3,xc=\"pbesol\",units=\"eV\")\n            H = BaS.H(np.linspace(100,700,1000),np.array(np.logspace(1, 7, 100),ndmin=2).transpose())\n\n        Args:\n\n            T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n            P (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\n            xc (str, optional): DFT XC functional used to calculate the ground state energy\n            units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n        Note:\n\n            T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix.\n            Other T, P arrays will result in undefined behaviour.\n\n        Returns:\n\n            H (float/ndarray): Enthalpy of one formula unit of solid expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n        \"\"\"\n        U_func = interpolate.get_potential_aims(self.phonon_filepath, \"U\")\n        PV = (\n            P\n            * self.volume\n            * 1e-30\n            * constants.physical_constants[\"joule-electron volt relationship\"][0]\n            / constants.N_A\n        )\n        E_dft = self.energies[xc]\n        H_eV = ((E_dft + U_func(T)) + PV) / self.fu_cell\n\n        if units == \"eV\":\n            return H_eV\n\n        elif units == \"J\":\n            return (\n                H_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n            )\n\n        elif units == \"kJ\":\n            return (\n                H_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n                * 0.001\n            )\n\n    def mu(self, T, P, xc=\"pbesol\", units=\"eV\"):\n        \"\"\"\n        Calculates the Gibbs Free Energy (mu = U + PV - TS) of one formula unit of solid.\n\n        Examples:\n\n            mu = BaS.mu(300,1E3,xc=\"pbesol\",units=\"eV\")\n            mu = BaS.mu(np.linspace(100,700,1000),np.array(np.logspace(1, 7, 100),ndmin=2).transpose())\n\n        Args:\n\n            T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n            P (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\n            xc (str, optional): DFT XC functional used to calculate the ground state energy\n            units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n        Note:\n\n            T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case mu is an m x n matrix.\n            Other T, P arrays will result in undefined behaviour.\n\n        Returns:\n\n            mu (float/ndarray): Gibbs Free Energy of one formula unit of solid expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n        \"\"\"\n        TS_func = interpolate.get_potential_aims(self.phonon_filepath, \"TS\")\n        H = self.H(T, P, xc=xc)\n        mu_eV = H - (TS_func(T)) / self.fu_cell\n\n        if units == \"eV\":\n            return mu_eV\n\n        elif units == \"J\":\n            return (\n                mu_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n            )\n\n        elif units == \"kJ\":\n            return (\n                mu_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n                * 0.001\n            )\n\n    def Cv(self, T, units=\"kB\"):\n        \"\"\"\n        Calculates the Constant-volume heat capacity of one formula unit of solid.\n\n        Examples:\n\n            Cv = BaS.mu(300,xc=\"pbesol\",units=\"eV\")\n            Cv = BaS.mu(np.linspace(100,700,1000),xc=\"pbesol\",units=\"kJ\")\n\n        Args:\n\n            T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n            xc (str, optional): DFT XC functional used to calculate the ground state energy\n            units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n        Returns:\n\n            Cv (float/ndarray): 1D Numpy array (with the same dimensions as T) containing the Constant-volume heat capacity of one formula unit of solid, or a single heat capacity float when a single temperature is passed as an argument.\n        \"\"\"\n        Cv_func = interpolate.get_potential_aims(self.phonon_filepath, \"Cv\")\n        Cv_kB = Cv_func(T) / self.fu_cell\n\n        if units == \"kB\":\n            return Cv_kB\n\n        elif units == \"eV\":\n            return Cv_kB * constants.physical_constants[\"Boltzmann constant in eV/K\"][0]\n\n        elif units == \"J\":\n            return (\n                Cv_kB\n                * constants.physical_constants[\"Boltzmann constant\"][0]\n                * constants.N_A\n            )\n\n        elif units == \"kJ\":\n            return (\n                Cv_kB\n                * constants.physical_constants[\"Boltzmann constant\"][0]\n                * constants.N_A\n                * 0.001\n            )\n</code></pre>"},{"location":"api/#thermopot.materials.Solid.Cv","title":"<code>Cv(T, units='kB')</code>","text":"<p>Calculates the Constant-volume heat capacity of one formula unit of solid.</p> <p>Examples:</p> <pre><code>Cv = BaS.mu(300,xc=\"pbesol\",units=\"eV\")\nCv = BaS.mu(np.linspace(100,700,1000),xc=\"pbesol\",units=\"kJ\")\n</code></pre> <p>Args:</p> <pre><code>T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\nxc (str, optional): DFT XC functional used to calculate the ground state energy\nunits (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n</code></pre> <p>Returns:</p> <pre><code>Cv (float/ndarray): 1D Numpy array (with the same dimensions as T) containing the Constant-volume heat capacity of one formula unit of solid, or a single heat capacity float when a single temperature is passed as an argument.\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>def Cv(self, T, units=\"kB\"):\n    \"\"\"\n    Calculates the Constant-volume heat capacity of one formula unit of solid.\n\n    Examples:\n\n        Cv = BaS.mu(300,xc=\"pbesol\",units=\"eV\")\n        Cv = BaS.mu(np.linspace(100,700,1000),xc=\"pbesol\",units=\"kJ\")\n\n    Args:\n\n        T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n        xc (str, optional): DFT XC functional used to calculate the ground state energy\n        units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n    Returns:\n\n        Cv (float/ndarray): 1D Numpy array (with the same dimensions as T) containing the Constant-volume heat capacity of one formula unit of solid, or a single heat capacity float when a single temperature is passed as an argument.\n    \"\"\"\n    Cv_func = interpolate.get_potential_aims(self.phonon_filepath, \"Cv\")\n    Cv_kB = Cv_func(T) / self.fu_cell\n\n    if units == \"kB\":\n        return Cv_kB\n\n    elif units == \"eV\":\n        return Cv_kB * constants.physical_constants[\"Boltzmann constant in eV/K\"][0]\n\n    elif units == \"J\":\n        return (\n            Cv_kB\n            * constants.physical_constants[\"Boltzmann constant\"][0]\n            * constants.N_A\n        )\n\n    elif units == \"kJ\":\n        return (\n            Cv_kB\n            * constants.physical_constants[\"Boltzmann constant\"][0]\n            * constants.N_A\n            * 0.001\n        )\n</code></pre>"},{"location":"api/#thermopot.materials.Solid.H","title":"<code>H(T, P, xc='pbesol', units='eV')</code>","text":"<p>Calculates the Enthalpy (H = U + PV) of one formula unit of solid.</p> <p>Examples:</p> <pre><code>H = BaS.H(300,1E3,xc=\"pbesol\",units=\"eV\")\nH = BaS.H(np.linspace(100,700,1000),np.array(np.logspace(1, 7, 100),ndmin=2).transpose())\n</code></pre> <p>Args:</p> <pre><code>T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\nP (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\nxc (str, optional): DFT XC functional used to calculate the ground state energy\nunits (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n</code></pre> <p>Note:</p> <pre><code>T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix.\nOther T, P arrays will result in undefined behaviour.\n</code></pre> <p>Returns:</p> <pre><code>H (float/ndarray): Enthalpy of one formula unit of solid expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>def H(self, T, P, xc=\"pbesol\", units=\"eV\"):\n    \"\"\"\n    Calculates the Enthalpy (H = U + PV) of one formula unit of solid.\n\n    Examples:\n\n        H = BaS.H(300,1E3,xc=\"pbesol\",units=\"eV\")\n        H = BaS.H(np.linspace(100,700,1000),np.array(np.logspace(1, 7, 100),ndmin=2).transpose())\n\n    Args:\n\n        T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n        P (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\n        xc (str, optional): DFT XC functional used to calculate the ground state energy\n        units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n    Note:\n\n        T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix.\n        Other T, P arrays will result in undefined behaviour.\n\n    Returns:\n\n        H (float/ndarray): Enthalpy of one formula unit of solid expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n    \"\"\"\n    U_func = interpolate.get_potential_aims(self.phonon_filepath, \"U\")\n    PV = (\n        P\n        * self.volume\n        * 1e-30\n        * constants.physical_constants[\"joule-electron volt relationship\"][0]\n        / constants.N_A\n    )\n    E_dft = self.energies[xc]\n    H_eV = ((E_dft + U_func(T)) + PV) / self.fu_cell\n\n    if units == \"eV\":\n        return H_eV\n\n    elif units == \"J\":\n        return (\n            H_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n        )\n\n    elif units == \"kJ\":\n        return (\n            H_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n            * 0.001\n        )\n</code></pre>"},{"location":"api/#thermopot.materials.Solid.U","title":"<code>U(T, xc='pbesol', units='eV')</code>","text":"<p>Calculates the internal energy of one formula unit of solid.</p> <p>Example:</p> <pre><code>U = BaS.U(300,xc=\"pbesol\",units=\"eV\")\n</code></pre> <p>Args:</p> <pre><code>T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\nxc (str, optional): DFT XC functional used to calculate the ground state energy\nunits (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n</code></pre> <p>Returns:</p> <pre><code>U (float/ndarray): 1D Numpy array (with the same dimensions as T) containing the internal energies of one formula unit of solid, or a single internal energy float when a single temperature is passed as an argument.\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>def U(self, T, xc=\"pbesol\", units=\"eV\"):\n    \"\"\"\n    Calculates the internal energy of one formula unit of solid.\n\n    Example:\n\n        U = BaS.U(300,xc=\"pbesol\",units=\"eV\")\n\n    Args:\n\n        T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n        xc (str, optional): DFT XC functional used to calculate the ground state energy\n        units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n    Returns:\n\n        U (float/ndarray): 1D Numpy array (with the same dimensions as T) containing the internal energies of one formula unit of solid, or a single internal energy float when a single temperature is passed as an argument.\n\n    \"\"\"\n    U_func = interpolate.get_potential_aims(self.phonon_filepath, \"U\")\n    E_dft = self.energies[xc]\n\n    U_eV = (E_dft + U_func(T)) / self.fu_cell\n\n    if units == \"eV\":\n        return U_eV\n\n    elif units == \"J\":\n        return (\n            U_eV(T, xc=xc)\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n        )\n\n    elif units == \"kJ\":\n        return (\n            U_eV(T, xc=xc)\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n            * 0.001\n        )\n</code></pre>"},{"location":"api/#thermopot.materials.Solid.__init__","title":"<code>__init__(name, stoichiometry, phonon_filepath, calculation=False, volume=False, energies=False, NAtoms=1)</code>","text":"<p>Args:</p> <p>name (str): Identifying string    stoichiometry (dict): relates element to the number of atoms in a single formula unit    phonon_filepath (str): path to the phonon output data    calculation (thermopot.calculation.Calculation, optional): instance of the thermopot.calculation.Calculation class    volume (float, optional): volume of unit cell in Angstroms^3    energies (dict, optional): relates xc functional to DFT total energy in eV    NAtoms (int): number of atoms in periodic unit cell</p> Source code in <code>thermopot/materials.py</code> <pre><code>def __init__(\n    self,\n    name,\n    stoichiometry,\n    phonon_filepath,\n    calculation=False,\n    volume=False,\n    energies=False,\n    NAtoms=1,\n):\n    \"\"\"\n    Args:\n\n       name (str): Identifying string\n       stoichiometry (dict): relates element to the number of atoms in a single formula unit\n       phonon_filepath (str): path to the phonon output data\n       calculation (thermopot.calculation.Calculation, optional): instance of the thermopot.calculation.Calculation class\n       volume (float, optional): volume of unit cell in Angstroms^3\n       energies (dict, optional): relates xc functional to DFT total energy in eV\n       NAtoms (int): number of atoms in periodic unit cell\n    \"\"\"\n\n    if calculation is not False:\n        if type(calculation) is not list:\n            Material.__init__(\n                self, name, stoichiometry, {calculation.xc: calculation.energy}\n            )\n            self.volume = calculation.volume\n            self.NAtoms = calculation.NAtoms\n        else:\n            pass\n\n    else:\n        Material.__init__(self, name, stoichiometry, energies)\n\n        self.NAtoms = NAtoms\n        self.volume = volume\n\n    self.fu_cell = self.NAtoms / self.N\n    self.phonon_filepath = materials_directory + phonon_filepath\n</code></pre>"},{"location":"api/#thermopot.materials.Solid.mu","title":"<code>mu(T, P, xc='pbesol', units='eV')</code>","text":"<p>Calculates the Gibbs Free Energy (mu = U + PV - TS) of one formula unit of solid.</p> <p>Examples:</p> <pre><code>mu = BaS.mu(300,1E3,xc=\"pbesol\",units=\"eV\")\nmu = BaS.mu(np.linspace(100,700,1000),np.array(np.logspace(1, 7, 100),ndmin=2).transpose())\n</code></pre> <p>Args:</p> <pre><code>T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\nP (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\nxc (str, optional): DFT XC functional used to calculate the ground state energy\nunits (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n</code></pre> <p>Note:</p> <pre><code>T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case mu is an m x n matrix.\nOther T, P arrays will result in undefined behaviour.\n</code></pre> <p>Returns:</p> <pre><code>mu (float/ndarray): Gibbs Free Energy of one formula unit of solid expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>def mu(self, T, P, xc=\"pbesol\", units=\"eV\"):\n    \"\"\"\n    Calculates the Gibbs Free Energy (mu = U + PV - TS) of one formula unit of solid.\n\n    Examples:\n\n        mu = BaS.mu(300,1E3,xc=\"pbesol\",units=\"eV\")\n        mu = BaS.mu(np.linspace(100,700,1000),np.array(np.logspace(1, 7, 100),ndmin=2).transpose())\n\n    Args:\n\n        T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n        P (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\n        xc (str, optional): DFT XC functional used to calculate the ground state energy\n        units (str, optional):  specifies the units as \"eV\", \"J\" (J/mol) or \"kJ\" (kJ/mol)\n\n    Note:\n\n        T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case mu is an m x n matrix.\n        Other T, P arrays will result in undefined behaviour.\n\n    Returns:\n\n        mu (float/ndarray): Gibbs Free Energy of one formula unit of solid expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n    \"\"\"\n    TS_func = interpolate.get_potential_aims(self.phonon_filepath, \"TS\")\n    H = self.H(T, P, xc=xc)\n    mu_eV = H - (TS_func(T)) / self.fu_cell\n\n    if units == \"eV\":\n        return mu_eV\n\n    elif units == \"J\":\n        return (\n            mu_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n        )\n\n    elif units == \"kJ\":\n        return (\n            mu_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n            * 0.001\n        )\n</code></pre>"},{"location":"api/#thermopot.materials.Sulfur_model","title":"<code>Sulfur_model</code>","text":"<p>             Bases: <code>object</code></p> <p>Class with parameterised model for sulfur chemical potential. From work of Jackson et al, https://doi.org/10.1039/C5SC03088A. Region of validity is 400 - 1500 K, 10^0 - 10^7 Pa. You must provide a reference energy from e.g. a DFT total energy calculation.</p> Source code in <code>thermopot/materials.py</code> <pre><code>class Sulfur_model(object):\n    \"\"\"\n    Class with parameterised model for sulfur chemical potential.\n    From work of Jackson et al, https://doi.org/10.1039/C5SC03088A.\n    Region of validity is 400 - 1500 K, 10^0 - 10^7 Pa.\n    You must provide a reference energy from e.g. a DFT total energy calculation.\n    \"\"\"\n\n    def __init__(self, reference_energy):\n        self.reference_energy = reference_energy\n\n    def mu(self, T, P, units=\"eV\", xc=None):\n        \"\"\"\n        Returns the chemical potential of one atom of Sulfur\n\n        Args:\n\n            T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n            P (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\n\n        Note:\n\n            T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case mu is an m x n matrix.\n            Other T, P arrays will result in undefined behaviour.\n\n        Returns:\n\n            mu (float/ndarray): Chemical potential of one sulfur atom expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n        \"\"\"\n\n        Kb = scipy.constants.physical_constants[\"Boltzmann constant in eV/K\"][0]\n\n        if (\n            np.any(T &gt; 1500)\n            or np.any(T &lt; 400)\n            or np.any(P &gt; 10**7)\n            or np.any(P &lt; 10**0)\n        ):\n            print(\n                \"\"\"WARNING!: You are using the sulfur model beyond the temperature and/or pressure range it was fitted to.\n                 Region of validity is 400 - 1500 K, 10^0 - 10^7 Pa. \"\"\"\n            )\n\n        def T_tr(P):\n            return (\n                5.077e2\n                + 7.272e1 * np.log10(P)\n                - 8.295 * np.log10(P) ** 2\n                + 1.828 * np.log10(P) ** 3\n            )\n\n        def mu_S_2(T, P):\n            return (\n                1.207\n                - 1.848e-3 * T\n                - 8.566e-7 * T**2\n                + 4.001e-10 * T**3\n                - 8.654e-14 * T**4\n                + Kb * T * np.log(P / 1e5)\n            )\n\n        def mu_S_8(T, P):\n            return (\n                7.62e-1\n                - 2.457e-3 * T\n                - 4.012e-6 * T**2\n                + 1.808e-9 * T**3\n                - 3.810e-13 * T**4\n                + Kb * T * np.log(P / 1e5)\n            )\n\n        def a_p(P):\n            return 1.465e-02 - 2.115e-03 * np.log10(P) + 6.905e-04 * np.log10(P) ** 2\n\n        b = 10\n        c = 80\n        w = 100\n\n        mu_eV = (\n            0.5 * (special.erfc((T - T_tr(P)) / w) * mu_S_8(T, P) / 8)\n            + 0.5 * ((special.erf((T - T_tr(P)) / w) + 1) * mu_S_2(T, P) / 2)\n            - a_p(P) * np.exp(-((T - T_tr(P) + b) ** 2) / (2 * c**2))\n            + self.reference_energy\n        )\n\n        if units == \"eV\":\n            return mu_eV\n\n        elif units == \"J\":\n            return (\n                mu_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n            )\n\n        elif units == \"kJ\":\n            return (\n                mu_eV\n                * constants.physical_constants[\"electron volt-joule relationship\"][0]\n                * constants.N_A\n                * 0.001\n            )\n</code></pre>"},{"location":"api/#thermopot.materials.Sulfur_model.mu","title":"<code>mu(T, P, units='eV', xc=None)</code>","text":"<p>Returns the chemical potential of one atom of Sulfur</p> <p>Args:</p> <pre><code>T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\nP (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\n</code></pre> <p>Note:</p> <pre><code>T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case mu is an m x n matrix.\nOther T, P arrays will result in undefined behaviour.\n</code></pre> <p>Returns:</p> <pre><code>mu (float/ndarray): Chemical potential of one sulfur atom expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n</code></pre> Source code in <code>thermopot/materials.py</code> <pre><code>def mu(self, T, P, units=\"eV\", xc=None):\n    \"\"\"\n    Returns the chemical potential of one atom of Sulfur\n\n    Args:\n\n        T (float/ndarray): 1D Numpy array containing temperature data (in Kelvin) as floats, or a single temperature as a float.\n        P (float/ndarray): 2D Numpy array with a single row containing pressure data (in Pa) as floats, or a single pressure as a float.\n\n    Note:\n\n        T, P are orthogonal 2D arrays of length m and n, populated in one row/column: in this case mu is an m x n matrix.\n        Other T, P arrays will result in undefined behaviour.\n\n    Returns:\n\n        mu (float/ndarray): Chemical potential of one sulfur atom expressed as floats in a m x n Numpy array where T, P are orthogonal 2D arrays of length m and n\n    \"\"\"\n\n    Kb = scipy.constants.physical_constants[\"Boltzmann constant in eV/K\"][0]\n\n    if (\n        np.any(T &gt; 1500)\n        or np.any(T &lt; 400)\n        or np.any(P &gt; 10**7)\n        or np.any(P &lt; 10**0)\n    ):\n        print(\n            \"\"\"WARNING!: You are using the sulfur model beyond the temperature and/or pressure range it was fitted to.\n             Region of validity is 400 - 1500 K, 10^0 - 10^7 Pa. \"\"\"\n        )\n\n    def T_tr(P):\n        return (\n            5.077e2\n            + 7.272e1 * np.log10(P)\n            - 8.295 * np.log10(P) ** 2\n            + 1.828 * np.log10(P) ** 3\n        )\n\n    def mu_S_2(T, P):\n        return (\n            1.207\n            - 1.848e-3 * T\n            - 8.566e-7 * T**2\n            + 4.001e-10 * T**3\n            - 8.654e-14 * T**4\n            + Kb * T * np.log(P / 1e5)\n        )\n\n    def mu_S_8(T, P):\n        return (\n            7.62e-1\n            - 2.457e-3 * T\n            - 4.012e-6 * T**2\n            + 1.808e-9 * T**3\n            - 3.810e-13 * T**4\n            + Kb * T * np.log(P / 1e5)\n        )\n\n    def a_p(P):\n        return 1.465e-02 - 2.115e-03 * np.log10(P) + 6.905e-04 * np.log10(P) ** 2\n\n    b = 10\n    c = 80\n    w = 100\n\n    mu_eV = (\n        0.5 * (special.erfc((T - T_tr(P)) / w) * mu_S_8(T, P) / 8)\n        + 0.5 * ((special.erf((T - T_tr(P)) / w) + 1) * mu_S_2(T, P) / 2)\n        - a_p(P) * np.exp(-((T - T_tr(P) + b) ** 2) / (2 * c**2))\n        + self.reference_energy\n    )\n\n    if units == \"eV\":\n        return mu_eV\n\n    elif units == \"J\":\n        return (\n            mu_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n        )\n\n    elif units == \"kJ\":\n        return (\n            mu_eV\n            * constants.physical_constants[\"electron volt-joule relationship\"][0]\n            * constants.N_A\n            * 0.001\n        )\n</code></pre>"},{"location":"api/#thermopot.reactions.Reaction","title":"<code>Reaction</code>","text":"<p>Class for reaction data</p>"},{"location":"api/#thermopot.reactions.Reaction--sets-properties","title":"Sets properties:","text":"<p>reaction.reactants     (Dict relating reactant materials to a number of formula units) reaction.products      (Dict relating product materials to a number of formular units)</p>"},{"location":"api/#thermopot.reactions.Reaction--sets-methods","title":"Sets methods:","text":"<p>reaction.DH(T,P) : Enthalpy of formation reaction.DU(T,P) : Internal energy change reaction.Dmu(T,P) : Gibbs free energy of formation</p> Source code in <code>thermopot/reactions.py</code> <pre><code>class Reaction:\n    \"\"\"\n    Class for reaction data\n\n    Sets properties:\n    -------------------\n    reaction.reactants     (Dict relating reactant materials to a number of formula units)\n    reaction.products      (Dict relating product materials to a number of formular units)\n\n    Sets methods:\n    -------------------\n    reaction.DH(T,P) : Enthalpy of formation\n    reaction.DU(T,P) : Internal energy change\n    reaction.Dmu(T,P) : Gibbs free energy of formation\n    \"\"\"\n\n    def __init__(\n        self,\n        reactants_dictionary,\n        products_dictionary,\n        temperature=298.15,\n        pressure=1e5,\n        fu=1,\n    ):\n        \"\"\"\n        reactants_dictionary and products dictionary takes the form { class_instance : formula units }\n        and can have an arbitrary number of key-value pairs. `Class instance` is an instance of the `materials.solid`\n        or `materials.ideal_gas` classes.\n\n        temperature is provided in kelvin, pressure is provided in Pa.\n\n        fu is the number of formula units of the final reactant(s). It is used to scale the calculated changes in energy/enthalpy.\n\n        \"\"\"\n        self.reactants = reactants_dictionary\n        self.products = products_dictionary\n        self.T = temperature\n        self.P = pressure\n        self.fu_scaling = fu\n\n    def DH(self, T=None, P=None, xc=\"pbesol\", units=\"eV\"):\n        T = self.T if T is None else T\n        P = self.P if P is None else P\n\n        reactants_enthalpy, products_enthalpy = 0, 0\n        for material, fu in self.reactants.items():\n            reactants_enthalpy += material.H(T, P, xc=xc, units=units) * fu\n        for material, fu in self.products.items():\n            products_enthalpy += material.H(T, P, xc=xc, units=units) * fu\n\n        return potential.Potential(\n            (products_enthalpy - reactants_enthalpy) / self.fu_scaling, T, P\n        )\n\n    def DU(self, T=None, P=None, xc=\"pbesol\", units=\"eV\"):\n        T = self.T if T is None else T\n        P = self.P if P is None else P\n\n        reactants_energy, products_energy = 0, 0\n        for material, fu in self.reactants.items():\n            reactants_energy += material.U(T, xc=xc, units=units) * fu\n        for material, fu in self.products.items():\n            products_energy += material.U(T, xc=xc, units=units) * fu\n\n        return potential.Potential(\n            (products_energy - reactants_energy) / self.fu_scaling, T, P\n        )\n\n    def Dmu(self, T=None, P=None, xc=\"pbesol\", units=\"eV\"):\n        T = self.T if T is None else T\n        P = self.P if P is None else P\n\n        reactants_energy, products_energy = 0, 0\n        for material, fu in self.reactants.items():\n            reactants_energy += material.mu(T, P, xc=xc, units=units) * fu\n        for material, fu in self.products.items():\n            products_energy += material.mu(T, P, xc=xc, units=units) * fu\n\n        return potential.Potential(\n            (products_energy - reactants_energy) / self.fu_scaling, T, P\n        )\n\n    def DE(self, xc=\"pbesol\"):\n        # units here are whatever is specified when creating material...\n\n        reactants_energy, products_energy = 0, 0\n\n        for material, fu in self.reactants.items():\n            reactants_energy += (material.energies[xc] / material.fu_cell) * fu\n        for material, fu in self.products.items():\n            products_energy += (material.energies[xc] / material.fu_cell) * fu\n\n        return (products_energy - reactants_energy) / self.fu_scaling\n</code></pre>"},{"location":"api/#thermopot.reactions.Reaction.__init__","title":"<code>__init__(reactants_dictionary, products_dictionary, temperature=298.15, pressure=100000.0, fu=1)</code>","text":"<p>reactants_dictionary and products dictionary takes the form { class_instance : formula units } and can have an arbitrary number of key-value pairs. <code>Class instance</code> is an instance of the <code>materials.solid</code> or <code>materials.ideal_gas</code> classes.</p> <p>temperature is provided in kelvin, pressure is provided in Pa.</p> <p>fu is the number of formula units of the final reactant(s). It is used to scale the calculated changes in energy/enthalpy.</p> Source code in <code>thermopot/reactions.py</code> <pre><code>def __init__(\n    self,\n    reactants_dictionary,\n    products_dictionary,\n    temperature=298.15,\n    pressure=1e5,\n    fu=1,\n):\n    \"\"\"\n    reactants_dictionary and products dictionary takes the form { class_instance : formula units }\n    and can have an arbitrary number of key-value pairs. `Class instance` is an instance of the `materials.solid`\n    or `materials.ideal_gas` classes.\n\n    temperature is provided in kelvin, pressure is provided in Pa.\n\n    fu is the number of formula units of the final reactant(s). It is used to scale the calculated changes in energy/enthalpy.\n\n    \"\"\"\n    self.reactants = reactants_dictionary\n    self.products = products_dictionary\n    self.T = temperature\n    self.P = pressure\n    self.fu_scaling = fu\n</code></pre>"},{"location":"api/#thermopot.potential.Potential","title":"<code>Potential</code>","text":"Source code in <code>thermopot/potential.py</code> <pre><code>class Potential:\n    def __init__(self, potential, T, P):\n        self.potential = potential\n        self.T = T\n        self.P = P\n\n    def plot_TvsP(\n        self,\n        potential_label=\"$\\Delta G_f$ / kJ mol$^{-1}$\",\n        scale_range=[-600, 0],\n        precision=\"%d\",\n        T_units=\"K\",\n        P_units=\"Pa\",\n        log_scale=True,\n    ):\n        \"\"\"\n        T is an array e.g. np.linspace(100, 1500, 100)  # K\n        P is an array orthogonal to T. e.g. np.array(np.logspace(1, 7, 100), ndmin=2).transpose()  # Pa\n        potential is returned from a reactions.reaction method called for an instance with attributes T,P.\n        If T has length m and P has length n, P will be a 2D array with dimensions m x n.\n        e.g. reactions.reaction({Ba:1,S:2}, {BaS2:1}},temperature=T,pressure=P).Dmu_eV_pbesol()\n        potential_label is the label of the contour colorbar e.g. '$\\Delta G_f$ / kJ mol$^{-1}$'\n        scale_range is the scale of the colorbar e.g. [-380, -240]\n        logscale determines if the y-axis Pressure is logarithmic\n        \"\"\"\n\n        mpl.rcParams[\"font.family\"] = \"serif\"\n        mpl.rcParams[\"font.serif\"] = \"Times New Roman\"\n        mpl.rcParams[\"font.size\"] = 16\n\n        # Unit conversions (all calculations are in SI units, conversion needed for plots)\n        if T_units == \"K\":\n            x_values = self.T\n            x_unitlabel = \"K\"\n        elif T_units == \"C\":\n            x_values = self.T - 273.15\n            x_unitlabel = \"$^\\circ$ C\"\n        else:\n            raise ValueError(\"Invalid temperature unit: {0}\".format(T_units))\n\n        if P_units == \"Pa\":\n            y_values = self.P.flatten()\n        elif P_units == \"Bar\" or P_units == \"bar\":\n            y_values = self.P.flatten() * 1e-5\n        elif P_units == \"mbar\":\n            y_values = self.P.flatten() * 1e-5 * 1e3\n        elif P_units == \"kPa\":\n            y_values = self.P.flatten() * 1e-3\n        elif P_units == \"mmHg\" or P_units == \"torr\":\n            y_values = self.P.flatten() * 760 / (1.01325e5)\n        else:\n            raise ValueError(\"Invalid pressure unit: {0}.\".format(T_units))\n\n        fig = plt.figure()\n        ax = fig.add_subplot(1, 1, 1)\n        colormap = plt.get_cmap(\"summer\")\n\n        a = plt.contour(\n            x_values, y_values, self.potential, 10, linewidths=1, colors=\"k\"\n        )\n        plt.pcolormesh(\n            x_values,\n            y_values,\n            self.potential,\n            cmap=colormap,\n            vmin=scale_range[0],\n            vmax=scale_range[1],\n            shading=\"auto\",\n        )\n        colours = plt.colorbar()\n        colours.set_label(potential_label, labelpad=20)\n\n        if log_scale:\n            ax.set_yscale(\"log\")\n        plt.clabel(a, fmt=precision)\n\n        plt.xlabel(\"Temperature / {0}\".format(x_unitlabel))\n        plt.ylabel(\"Pressure / {0}\".format(P_units))\n\n        return plt\n</code></pre>"},{"location":"api/#thermopot.potential.Potential.plot_TvsP","title":"<code>plot_TvsP(potential_label='$\\\\Delta G_f$ / kJ mol$^{-1}$', scale_range=[-600, 0], precision='%d', T_units='K', P_units='Pa', log_scale=True)</code>","text":"<p>T is an array e.g. np.linspace(100, 1500, 100)  # K P is an array orthogonal to T. e.g. np.array(np.logspace(1, 7, 100), ndmin=2).transpose()  # Pa potential is returned from a reactions.reaction method called for an instance with attributes T,P. If T has length m and P has length n, P will be a 2D array with dimensions m x n. e.g. reactions.reaction({Ba:1,S:2}, {BaS2:1}},temperature=T,pressure=P).Dmu_eV_pbesol() potential_label is the label of the contour colorbar e.g. '$\\Delta G_f$ / kJ mol$^{-1}$' scale_range is the scale of the colorbar e.g. [-380, -240] logscale determines if the y-axis Pressure is logarithmic</p> Source code in <code>thermopot/potential.py</code> <pre><code>def plot_TvsP(\n    self,\n    potential_label=\"$\\Delta G_f$ / kJ mol$^{-1}$\",\n    scale_range=[-600, 0],\n    precision=\"%d\",\n    T_units=\"K\",\n    P_units=\"Pa\",\n    log_scale=True,\n):\n    \"\"\"\n    T is an array e.g. np.linspace(100, 1500, 100)  # K\n    P is an array orthogonal to T. e.g. np.array(np.logspace(1, 7, 100), ndmin=2).transpose()  # Pa\n    potential is returned from a reactions.reaction method called for an instance with attributes T,P.\n    If T has length m and P has length n, P will be a 2D array with dimensions m x n.\n    e.g. reactions.reaction({Ba:1,S:2}, {BaS2:1}},temperature=T,pressure=P).Dmu_eV_pbesol()\n    potential_label is the label of the contour colorbar e.g. '$\\Delta G_f$ / kJ mol$^{-1}$'\n    scale_range is the scale of the colorbar e.g. [-380, -240]\n    logscale determines if the y-axis Pressure is logarithmic\n    \"\"\"\n\n    mpl.rcParams[\"font.family\"] = \"serif\"\n    mpl.rcParams[\"font.serif\"] = \"Times New Roman\"\n    mpl.rcParams[\"font.size\"] = 16\n\n    # Unit conversions (all calculations are in SI units, conversion needed for plots)\n    if T_units == \"K\":\n        x_values = self.T\n        x_unitlabel = \"K\"\n    elif T_units == \"C\":\n        x_values = self.T - 273.15\n        x_unitlabel = \"$^\\circ$ C\"\n    else:\n        raise ValueError(\"Invalid temperature unit: {0}\".format(T_units))\n\n    if P_units == \"Pa\":\n        y_values = self.P.flatten()\n    elif P_units == \"Bar\" or P_units == \"bar\":\n        y_values = self.P.flatten() * 1e-5\n    elif P_units == \"mbar\":\n        y_values = self.P.flatten() * 1e-5 * 1e3\n    elif P_units == \"kPa\":\n        y_values = self.P.flatten() * 1e-3\n    elif P_units == \"mmHg\" or P_units == \"torr\":\n        y_values = self.P.flatten() * 760 / (1.01325e5)\n    else:\n        raise ValueError(\"Invalid pressure unit: {0}.\".format(T_units))\n\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    colormap = plt.get_cmap(\"summer\")\n\n    a = plt.contour(\n        x_values, y_values, self.potential, 10, linewidths=1, colors=\"k\"\n    )\n    plt.pcolormesh(\n        x_values,\n        y_values,\n        self.potential,\n        cmap=colormap,\n        vmin=scale_range[0],\n        vmax=scale_range[1],\n        shading=\"auto\",\n    )\n    colours = plt.colorbar()\n    colours.set_label(potential_label, labelpad=20)\n\n    if log_scale:\n        ax.set_yscale(\"log\")\n    plt.clabel(a, fmt=precision)\n\n    plt.xlabel(\"Temperature / {0}\".format(x_unitlabel))\n    plt.ylabel(\"Pressure / {0}\".format(P_units))\n\n    return plt\n</code></pre>"},{"location":"api/#thermopot.potentials.Potentials","title":"<code>Potentials</code>","text":"Source code in <code>thermopot/potentials.py</code> <pre><code>class Potentials:\n    def __init__(self, *potentials):\n        self.potentials = potentials\n        self.minimum_potential = self.find_potential_minimum()\n        self.T = self.potentials[0].T\n        self.P = self.potentials[0].P\n\n    # TODO: check that all the potentials are plottable over T/P range\n\n    def plot_TvsP(\n        self,\n        material_labels=None,\n        T_units=\"K\",\n        P_units=\"Pa\",\n        log_scale=True,\n    ):\n        \"\"\"\n        T is an array e.g. np.linspace(100, 1500, 100)  # K\n        P is an array orthogonal to T. e.g. np.array(np.logspace(1, 7, 100), ndmin=2).transpose()  # Pa\n        potential is returned from a reactions.reaction method called for an instance with attributes T,P.\n        If T has length m and P has length n, P will be a 2D array with dimensions m x n.\n        e.g. reactions.reaction({Ba:1,S:2}, {BaS2:1}},temperature=T,pressure=P).Dmu_eV_pbesol()\n        potential_label is the label of the contour colorbar e.g. '$\\Delta G_f$ / kJ mol$^{-1}$'\n        scale_range is the scale of the colorbar e.g. [-380, -240]\n        log_scale determines if the Pressure y-axis is logarithmic\n        \"\"\"\n\n        mpl.rcParams[\"font.family\"] = \"serif\"\n        mpl.rcParams[\"font.serif\"] = \"Times New Roman\"\n        mpl.rcParams[\"font.size\"] = 16\n\n        # Unit conversions (all calculations are in SI units, conversion needed for plots)\n\n        if T_units == \"K\":\n            x_values = self.T\n            x_unitlabel = \"K\"\n        elif T_units == \"C\":\n            x_values = self.T - 273.15\n            x_unitlabel = \"$^\\circ$ C\"\n        else:\n            raise ValueError(\"Invalid temperature unit: {0}\".format(T_units))\n\n        if P_units == \"Pa\":\n            y_values = self.P.flatten()\n        elif P_units == \"Bar\" or P_units == \"bar\":\n            y_values = self.P.flatten() * 1e-5\n        elif P_units == \"mbar\":\n            y_values = self.P.flatten() * 1e-5 * 1e3\n        elif P_units == \"kPa\":\n            y_values = self.P.flatten() * 1e-3\n        elif P_units == \"mmHg\" or P_units == \"torr\":\n            y_values = self.P.flatten() * 760 / (1.01325e5)\n        else:\n            raise ValueError(\"Invalid pressure unit: {0}.\".format(T_units))\n\n        fig = plt.figure()\n        ax = fig.add_subplot(1, 1, 1)\n        colormap = plt.get_cmap(\"summer\")\n\n        potential = self.find_potential_minimum()\n        plt.pcolormesh(\n            x_values,\n            y_values,\n            potential / (len(material_labels) - 1),\n            cmap=colormap,\n            shading=\"auto\",\n        )\n        # TODO: sort the colour map out so consistent with grid. Now ranges from 0 to 1\n\n        # Set borders in the interval [0, 1]\n        bound = np.linspace(0, 1, len(material_labels))\n\n        # AT THE MOMENT THIS IS BROKEN!!!!\n        # plt.legend(\n        #    [mpatches.Patch(color=colormap(i)) for i in bound],\n        #    [\"{:s}\".format(material_labels[i]) for i in range(len(material_labels))],\n        # )\n\n        plt.xlabel(\"Temperature / {0}\".format(x_unitlabel))\n        plt.ylabel(\"Pressure / {0}\".format(P_units))\n        if log_scale:\n            ax.set_yscale(\"log\")\n\n        return plt\n\n    def find_potential_minimum(self):\n        assert (\n            len(set([potential.potential.shape for potential in self.potentials])) == 1\n        ), \"potential arrays must have the same dimension\"\n\n        minimum_potential = self.potentials[0].potential\n        for i, potential in enumerate(self.potentials):\n            minimum_potential = np.minimum(\n                minimum_potential, self.potentials[i + 1].potential\n            )\n            if i + 2 == len(self.potentials):\n                break\n\n        for i, potential in enumerate(self.potentials):\n            minimum_potential[potential.potential == minimum_potential] = i\n\n        return minimum_potential\n</code></pre>"},{"location":"api/#thermopot.potentials.Potentials.plot_TvsP","title":"<code>plot_TvsP(material_labels=None, T_units='K', P_units='Pa', log_scale=True)</code>","text":"<p>T is an array e.g. np.linspace(100, 1500, 100)  # K P is an array orthogonal to T. e.g. np.array(np.logspace(1, 7, 100), ndmin=2).transpose()  # Pa potential is returned from a reactions.reaction method called for an instance with attributes T,P. If T has length m and P has length n, P will be a 2D array with dimensions m x n. e.g. reactions.reaction({Ba:1,S:2}, {BaS2:1}},temperature=T,pressure=P).Dmu_eV_pbesol() potential_label is the label of the contour colorbar e.g. '$\\Delta G_f$ / kJ mol$^{-1}$' scale_range is the scale of the colorbar e.g. [-380, -240] log_scale determines if the Pressure y-axis is logarithmic</p> Source code in <code>thermopot/potentials.py</code> <pre><code>def plot_TvsP(\n    self,\n    material_labels=None,\n    T_units=\"K\",\n    P_units=\"Pa\",\n    log_scale=True,\n):\n    \"\"\"\n    T is an array e.g. np.linspace(100, 1500, 100)  # K\n    P is an array orthogonal to T. e.g. np.array(np.logspace(1, 7, 100), ndmin=2).transpose()  # Pa\n    potential is returned from a reactions.reaction method called for an instance with attributes T,P.\n    If T has length m and P has length n, P will be a 2D array with dimensions m x n.\n    e.g. reactions.reaction({Ba:1,S:2}, {BaS2:1}},temperature=T,pressure=P).Dmu_eV_pbesol()\n    potential_label is the label of the contour colorbar e.g. '$\\Delta G_f$ / kJ mol$^{-1}$'\n    scale_range is the scale of the colorbar e.g. [-380, -240]\n    log_scale determines if the Pressure y-axis is logarithmic\n    \"\"\"\n\n    mpl.rcParams[\"font.family\"] = \"serif\"\n    mpl.rcParams[\"font.serif\"] = \"Times New Roman\"\n    mpl.rcParams[\"font.size\"] = 16\n\n    # Unit conversions (all calculations are in SI units, conversion needed for plots)\n\n    if T_units == \"K\":\n        x_values = self.T\n        x_unitlabel = \"K\"\n    elif T_units == \"C\":\n        x_values = self.T - 273.15\n        x_unitlabel = \"$^\\circ$ C\"\n    else:\n        raise ValueError(\"Invalid temperature unit: {0}\".format(T_units))\n\n    if P_units == \"Pa\":\n        y_values = self.P.flatten()\n    elif P_units == \"Bar\" or P_units == \"bar\":\n        y_values = self.P.flatten() * 1e-5\n    elif P_units == \"mbar\":\n        y_values = self.P.flatten() * 1e-5 * 1e3\n    elif P_units == \"kPa\":\n        y_values = self.P.flatten() * 1e-3\n    elif P_units == \"mmHg\" or P_units == \"torr\":\n        y_values = self.P.flatten() * 760 / (1.01325e5)\n    else:\n        raise ValueError(\"Invalid pressure unit: {0}.\".format(T_units))\n\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    colormap = plt.get_cmap(\"summer\")\n\n    potential = self.find_potential_minimum()\n    plt.pcolormesh(\n        x_values,\n        y_values,\n        potential / (len(material_labels) - 1),\n        cmap=colormap,\n        shading=\"auto\",\n    )\n    # TODO: sort the colour map out so consistent with grid. Now ranges from 0 to 1\n\n    # Set borders in the interval [0, 1]\n    bound = np.linspace(0, 1, len(material_labels))\n\n    # AT THE MOMENT THIS IS BROKEN!!!!\n    # plt.legend(\n    #    [mpatches.Patch(color=colormap(i)) for i in bound],\n    #    [\"{:s}\".format(material_labels[i]) for i in range(len(material_labels))],\n    # )\n\n    plt.xlabel(\"Temperature / {0}\".format(x_unitlabel))\n    plt.ylabel(\"Pressure / {0}\".format(P_units))\n    if log_scale:\n        ax.set_yscale(\"log\")\n\n    return plt\n</code></pre>"},{"location":"api/#thermopot.interpolate.get_potential_aims","title":"<code>get_potential_aims(file, property)</code>","text":"<p>Thermodynamic property interpolation function. Requires phonopy-FHI-aims output file. Reads data for S and Cv expressed in J/K/mol, F and U in kJ/mol, TS in J/mol. Outputs data for S and Cv in kB/cell, U, F and TS in eV/cell.</p> Source code in <code>thermopot/interpolate.py</code> <pre><code>def get_potential_aims(file, property):\n    \"\"\"Thermodynamic property interpolation function. Requires phonopy-FHI-aims output file.\n    Reads data for S and Cv expressed in J/K/mol, F and U in kJ/mol,\n    TS in J/mol.\n    Outputs data for S and Cv in kB/cell, U, F and TS in eV/cell.\n    \"\"\"\n    data = genfromtxt(file)\n    T = data[:, 0]\n    if property in (\"Cv\", \"Cp\", \"heat_capacity\", \"C\"):\n        potential = data[:, 3] / kB2JKmol\n    elif property in (\"U\", \"internal_energy\"):\n        potential = data[:, 4] / eV2kJmol\n    elif property in (\"F\", \"A\", \"Helmholtz\", \"free_energy\"):\n        potential = data[:, 1] / eV2kJmol\n    elif property in (\"S\", \"Entropy\", \"entropy\"):\n        potential = data[:, 2] / kB2JKmol\n    elif property in (\"TS\"):\n        potential = (T * data[:, 2]) / eV2Jmol\n    else:\n        raise RuntimeError(\"Property not found\")\n    thefunction = interp1d(T, potential, kind=\"linear\")\n\n    return thefunction\n</code></pre>"},{"location":"api/#thermopot.interpolate.get_potential_nist_table","title":"<code>get_potential_nist_table(file, property)</code>","text":"<p>Thermodynamic property interpolation function. Requires NIST-JANAF table. All properties in J, mol and K</p> Source code in <code>thermopot/interpolate.py</code> <pre><code>def get_potential_nist_table(file, property):\n    \"\"\"Thermodynamic property interpolation function. Requires NIST-JANAF table. All properties in J, mol and K\"\"\"\n    data = genfromtxt(file, skip_header=2)\n    T = data[:, 0]\n    if property in (\"Cp\", \"C\", \"heat_capacity\"):\n        potential = data[:, 1]\n    elif property in (\"S\", \"entropy\"):\n        potential = data[:, 2]\n    elif property in (\"H\", \"enthalpy\"):\n        potential = (data[:, 4] - data[0, 4]) * 1e3\n    elif property in (\"U\", \"internal_energy\"):\n        # U = H - PV; for ideal gas molar PV = RT so U = H - RT\n        from scipy.constants import R as R\n\n        potential = (data[:, 4] - data[0, 4]) * 1e3 - R * data[:, 0]\n    elif property in (\"DH\", \"Delta_H\", \"standard_enthalpy_change\"):\n        potential = data[:, 4] * 1e3\n    else:\n        raise RuntimeError(\"Property not found\")\n\n    thefunction = interp1d(T, potential, kind=\"cubic\")\n    return thefunction\n</code></pre>"},{"location":"api/#thermopot.interpolate.get_potential_sulfur_table","title":"<code>get_potential_sulfur_table(filename)</code>","text":"<p>Read thermodynamic property as function of T, P from datafile.</p> <p>Datafile should be generated by the code at http://github.com/WMD-bath/sulfur-model or follow the same format</p> Source code in <code>thermopot/interpolate.py</code> <pre><code>def get_potential_sulfur_table(filename):\n    \"\"\"\n    Read thermodynamic property as function of T, P from datafile.\n\n    Datafile should be generated by the code at http://github.com/WMD-bath/sulfur-model\n    or follow the same format\n\n    \"\"\"\n    # Import chemical potential in J mol-1 vs T, P from file\n    data = genfromtxt(filename, comments=\"#\", delimiter=\",\")\n    T = data[:, 0].flatten()\n    with open(filename, \"r\") as f:\n        header = f.readline()\n    P = [float(p) for p in re.findall(r\"\\d+.\\d+\", header)]\n    thefunction = interp2d(T, np.log(P), data[:, 1:].transpose(), kind=\"cubic\")\n\n    def lin_P_function(T, P):\n        return thefunction(T, np.log(P))\n\n    return lin_P_function\n</code></pre>"},{"location":"background/","title":"Background","text":"<p>This software is used to calculate the thermodynamic potentials of materials and ideal gases. The calculations are based on energetic and vibrational data from theory (for example, density functional theory) or experiment. By calculating the thermodynamic potentials of both products and reactants, this software can also produce a thermodynamic model for the stability of a material under arbitrary temperatures and pressures. </p>"},{"location":"background/#research-outputs","title":"Research outputs","text":"<ul> <li>This model was originally developed for the photovoltaic material CZTS and published in a 2014 publication in J. Mater. Chem. A.</li> <li>It has been more recently applied to the chalcogenide perovskite BaZrS3 and published in a 2023 publication in Solar RRL.</li> </ul>"},{"location":"background/#experimental-data","title":"Experimental data","text":"<p>Experimental data is used to model the pressure and temperature dependance of gases. In particular the NIST-JANAF thermochemical tables are used: Chase, M. W. J. NIST-JANAF Thermochemical Tables, Fourth Edition. J. Phys. Chem. Ref. Data, Monogr. 9, 1-1951 (1998). https://srd.nist.gov/JPCRD/jpcrdM9.pdf.</p>"},{"location":"background/#further-reading","title":"Further reading","text":"<ul> <li>Materials Stability and Nature's bike shop: A comics guide to predicting new materials, Anubhav Jain (2014). Link here</li> <li>Phase Diagrams: The Beginning of Wisdom. Rainer Schmid-Fetzer (2014): Link here.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thanks for your interest in ThermoPot - we welcome your help in improving and extending this package. </p> <p>This project follows the all-contributors  specification. Contributions of any kind are welcome! A full list of  possible contribution types can be found here. You do not need to be an experienced programmer  to help improve ThermoPot.</p> <p>All contributions will be recognised on the README.md. You are encouraged to log your own contribution using the all-contributors bot. The project lead(s) will also maintain this list.</p> <p>ThermoPot contributors are asked to follow the Contributor Covenant Code of  Conduct.</p>"},{"location":"contributing/#contributions-workflow","title":"Contributions workflow","text":"<p>Code contributions are primarily managed through Github pull requests. For external contributions we prefer the \u201cfork and pull\u201d workflow:</p> <ol> <li>open an Issue to discuss the proposed contribution. </li> <li>make your own project fork and implement the changes there</li> <li>open a pull requestion (PR) to merge the changes into the main project. Further discussion might also take place at this stage.</li> </ol> <p>Note: Please, where applicable and possible, write tests and documentation for your proposed code contributions (further details below). Support can be given to those who are writing tests and documentation for the first time \ud83d\ude0a</p>"},{"location":"contributing/#communication","title":"Communication","text":"<p>As a rule of thumb, the more public the information exchange, the better! With this in mind, we encourage you to raise an issue on the ThermoPot repository.</p> <p>However we also understand that this public way of working is not suitable for everyone. As an alternative, you can get get in contact with the project lead Lucy. </p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Github Actions and Pytest is used to automatically test all commits to the main branch of the ThermoPot repository. If possible, please write tests for your code when issuing a Pull Request; <code>./tests/conftest.py</code> contains pytest fixtures which may be of use. Test files and test data can be found in the <code>tests/</code> folder.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Github Actions is used to automatically build and publish code documentation after each commit to the main branch of the ThermoPot repository. All documentation is written in Markdown using the MkDocs framework and the Material theme. This also includes the automatic generation of API documentation using the mkdocstrings plugin. </p> <p>If possible, please update the documentation when issuing a Pull Request. This includes both the web pages written in Markdown, and in-code docstrings. The latter are particularly important, and we request that these are written Google-style.</p> <p>All documentation source can be found in the <code>docs/</code> folder. MkDocs is configured with the <code>/.mkdocs.yml</code> folder in the project root.</p>"},{"location":"contributing/#linting","title":"Linting","text":"<p>Github Actions and Black are used to  automatically re-format all Python code committed to the  repository. The code  will be formatted according to the PEP8  specification. As this is an automatic step you do not need lint/format your code to any specification before issuing a PR.</p>"},{"location":"contributing/#publishing","title":"Publishing","text":"<p>Github Actions (surprise, surprise!) is used to automatically build and publish the ThermoPot package after every tagged release. Before tagging the release, we need to remember to update the version number in <code>__init__.py</code>. It's so easy to forget!</p>"},{"location":"installation/","title":"Installation","text":"<p>ThermoPot can be installed using the Python package manader <code>pip</code>:</p> <p><code>pip install thermopot</code></p> <p>If you use conda/anaconda, the safest thing to do is to create a new environment and then install ThermoPot:</p> <pre><code>conda create -n thermopot python\nconda activate thermopot\npip install thermopot\n</code></pre> <p>If you wish, you can install the very latest version of ThermoPot from Github. Note that although the latest Github version may include more features, it may not be stable. To install the latest, possibly unstable version:</p> <pre><code>git clone https://github.com/NU-CEM/ThermoPot.git\ncd ThermoPot\npip install .\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>In this tutorial we will explore the functionality of ThermoPot using the chalcogenide perovskite BaZrS$_3$ as a motivating example. We will consider three reactions:</p> <p>(1) BaZrS$_3$ -&gt; BaS + ZrS$_2$</p> <p>(2) BaZrS$_3$ -&gt; Ba + Zr + 3S</p> <p>(3) BaZrS$_3$ -&gt; BaS$_2$ + ZrS</p> <p>We will use ThermoPot to calculate the change in Gibbs free energy for each of these reactions, at a range of temperature and pressures. We will also identify at which temperatures and pressures (if any) the perovskite decomposes into it's competing binary (BaS, BaS2, ZrS, ZrS$_2$) or elemental (Ba, Zr, S) phases.</p> <p>To do these calculations we need the total ground-state energy of each material, calculated using DFT or else-wise. For predictions and finite temperature and pressure we need, in addition, vibrational data for each material. For solid materials this can also be calculated from first-principles using harmonic lattice dynamical theory. For gaseous compounds (not considered in this tutorial), where there is a strong dependence on pressures close to standard pressure, experimental data can be used.</p> In\u00a0[1]: Copied! <pre>from thermopot import calculations, materials, reactions, potentials\n</pre> from thermopot import calculations, materials, reactions, potentials In\u00a0[2]: Copied! <pre>BaS_calc = calculations.Calculation(volume=63.2552,energy=-235926.586148547,\n                            xc='pbesol',\n                        NAtoms=2)\nvars(BaS_calc)\n</pre> BaS_calc = calculations.Calculation(volume=63.2552,energy=-235926.586148547,                             xc='pbesol',                         NAtoms=2) vars(BaS_calc) Out[2]: <pre>{'volume': 63.2552,\n 'filepath': None,\n 'energy': -235926.586148547,\n 'xc': 'pbesol',\n 'NAtoms': 2}</pre> In\u00a0[7]: Copied! <pre>BaS_calc = calculations.AimsCalculation(\"../BaZrS3/raw_aims_files/binary/BaS_Fm-3m/pbesol/aims.out\")\nvars(BaS_calc)\n</pre> BaS_calc = calculations.AimsCalculation(\"../BaZrS3/raw_aims_files/binary/BaS_Fm-3m/pbesol/aims.out\") vars(BaS_calc) Out[7]: <pre>{'volume': 63.2552,\n 'filepath': '../BaZrS3/raw_aims_files/binary/BaS_Fm-3m/pbesol/aims.out',\n 'energy': -235926.58614863,\n 'xc': 'pbesol',\n 'NAtoms': 2}</pre> <p>For in-notebook help with functions, docstrings can be accessed with a <code>?</code> to trigger the docstring for the class. Alternatively, a Python <code>help()</code> function can be used. Feel free to use this for any object to fimilarise yourself with the internal workings of the code.</p> In\u00a0[8]: Copied! <pre>calculations.AimsCalculation?\nhelp(calculations.AimsCalculation)\n</pre> calculations.AimsCalculation? help(calculations.AimsCalculation) <pre>Help on class AimsCalculation in module thermopot.calculations:\n\nclass AimsCalculation(Calculation)\n |  AimsCalculation(filepath='./calculation.out')\n |  \n |  Class for parsing and storing data from a FHI-AIMS total energy calculation.\n |  \n |  Example:\n |  \n |      AimsCalculation(\"./aims_output/output.aims\")\n |  \n |  Attributes:\n |  \n |      volume (float): volume of the periodic unit cell in Angstrom^3\n |      filepath (str): path to the calculation output files\n |      energy (float): DFT total energy in eV\n |      xc (str): XC functional used to calculate the total energy\n |      NAtoms (int): number of atoms in the periodic unit cell\n |  \n |  Method resolution order:\n |      AimsCalculation\n |      Calculation\n |      builtins.object\n |  \n |  Methods defined here:\n |  \n |  __init__(self, filepath='./calculation.out')\n |      Args:\n |      \n |          filepath (str): path to the calculation output files\n |  \n |  get_NAtoms(self)\n |      Returns:\n |      \n |          (int): number of atoms in the periodic unit cell\n |  \n |  get_energy(self)\n |      Returns:\n |      \n |          (float): DFT total energy in eV\n |  \n |  get_volume(self)\n |      Returns:\n |      \n |          (float): volume of the periodic unit cell in Angstrom^3\n |  \n |  get_xc(self)\n |      Returns:\n |      \n |          (str): XC functional used to calculate the total energy\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from Calculation:\n |  \n |  check_attributes(self)\n |      Check that the Calculation class attributes make basic sense.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Calculation:\n |  \n |  __dict__\n |      dictionary for instance variables (if defined)\n |  \n |  __weakref__\n |      list of weak references to the object (if defined)\n\n</pre> <p>We will now read in the calculations for the other compounds.</p> In\u00a0[9]: Copied! <pre>BaZrS3_calc = calculations.AimsCalculation(\"../BaZrS3/raw_aims_files/ternary/BaZrS3_Pnma/pbesol/aims.out\")\nZrS2_calc =  calculations.AimsCalculation(\"../BaZrS3/raw_aims_files/binary/ZrS2_P-3m1/pbesol/aims.out\")\n</pre> BaZrS3_calc = calculations.AimsCalculation(\"../BaZrS3/raw_aims_files/ternary/BaZrS3_Pnma/pbesol/aims.out\") ZrS2_calc =  calculations.AimsCalculation(\"../BaZrS3/raw_aims_files/binary/ZrS2_P-3m1/pbesol/aims.out\") <p>For in-notebook help with functions, docstrings can be accessed with a <code>?</code> to trigger the docstring for the class. Alternatively, a Python <code>help()</code> function can be used.</p> <p>The attributes (name, stoichiometry, filepath of ) of a <code>materials.Solid</code> has to be stored in a variable.</p> In\u00a0[10]: Copied! <pre>BaZrS3 = materials.Solid('BaZrS3',{\"Ba\":1,\"Zr\":1,\"S\":3},\"../BaZrS3/phonopy_output/BaZrS3_Pnma.dat\",BaZrS3_calc)\n\nBaS = materials.Solid('BaS',{\"Ba\":1,\"S\":1},\"../BaZrS3/phonopy_output/BaS_Fm-3m.dat\",BaS_calc)\n\nZrS2 = materials.Solid('ZrS2',{\"Zr\":1,\"S\":2},\"../BaZrS3/phonopy_output/ZrS2_P-3m1.dat\",ZrS2_calc)\n</pre> BaZrS3 = materials.Solid('BaZrS3',{\"Ba\":1,\"Zr\":1,\"S\":3},\"../BaZrS3/phonopy_output/BaZrS3_Pnma.dat\",BaZrS3_calc)  BaS = materials.Solid('BaS',{\"Ba\":1,\"S\":1},\"../BaZrS3/phonopy_output/BaS_Fm-3m.dat\",BaS_calc)  ZrS2 = materials.Solid('ZrS2',{\"Zr\":1,\"S\":2},\"../BaZrS3/phonopy_output/ZrS2_P-3m1.dat\",ZrS2_calc) In\u00a0[11]: Copied! <pre>vars(BaZrS3)\n</pre> vars(BaZrS3) Out[11]: <pre>{'name': 'BaZrS3',\n 'stoichiometry': {'Ba': 1, 'Zr': 1, 'S': 3},\n 'energies': {'pbesol': -1425527.242293353},\n 'N': 5,\n 'volume': 484.624,\n 'NAtoms': 20,\n 'fu_cell': 4.0,\n 'phonons': '/Users/prakriti/development/ThermoPot/thermopot/../BaZrS3/phonopy_output/BaZrS3_Pnma.dat'}</pre> <p>We model the combination or decomposition of <code>materials</code> with the <code>reaction</code> class where the formula unit of reactants and products are defined.</p> In\u00a0[12]: Copied! <pre>reaction_one = reactions.Reaction({BaZrS3:1}, {BaS:1,ZrS2:1})\n</pre> reaction_one = reactions.Reaction({BaZrS3:1}, {BaS:1,ZrS2:1}) In\u00a0[14]: Copied! <pre>vars(reaction_one)\n</pre> vars(reaction_one) Out[14]: <pre>{'reactants': {&lt;thermopot.materials.Solid at 0x1298b7310&gt;: 1},\n 'products': {&lt;thermopot.materials.Solid at 0x1298b7ca0&gt;: 1,\n  &lt;thermopot.materials.Solid at 0x1298b6530&gt;: 1},\n 'T': 298.15,\n 'P': 100000.0,\n 'fu_scaling': 1}</pre> In\u00a0[26]: Copied! <pre>import numpy as np\n\nT = np.linspace(100, 1000, 100)\nP = np.array(np.logspace(1, 7, 100), ndmin=2).transpose()\n\nreaction_one.Dmu(T,P)\n</pre> import numpy as np  T = np.linspace(100, 1000, 100) P = np.array(np.logspace(1, 7, 100), ndmin=2).transpose()  reaction_one.Dmu(T,P) Out[26]: <pre>&lt;thermopot.potential.Potential at 0x129b9a980&gt;</pre> In\u00a0[27]: Copied! <pre>GFE_reaction_one = reactions.Reaction\n</pre> GFE_reaction_one = reactions.Reaction In\u00a0[28]: Copied! <pre>import numpy as np\n\nT = np.linspace(100, 1000, 100)\nP = np.array(np.logspace(1, 7, 100), ndmin=2).transpose()\n\nGFE = GFE_reaction_one.Dmu(T,P) / 1000\n</pre> import numpy as np  T = np.linspace(100, 1000, 100) P = np.array(np.logspace(1, 7, 100), ndmin=2).transpose()  GFE = GFE_reaction_one.Dmu(T,P) / 1000 <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In [28], line 6\n      3 T = np.linspace(100, 1000, 100)\n      4 P = np.array(np.logspace(1, 7, 100), ndmin=2).transpose()\n----&gt; 6 GFE = GFE_reaction_one.Dmu(T,P) / 1000\n\nFile ~/development/ThermoPot/thermopot/reactions.py:79, in Reaction.Dmu(self, T, P, xc, units)\n     76 def Dmu(self, T=None, P=None, xc=\"pbesol\", units=\"eV\"):\n     78     T = self.T if T is None else T\n---&gt; 79     P = self.P if P is None else P\n     81     reactants_energy, products_energy = 0, 0\n     82     for material, fu in self.reactants.items():\n\nAttributeError: 'numpy.ndarray' object has no attribute 'P'</pre> In\u00a0[22]: Copied! <pre>plots.plot_TvsP(T,P,GFE)\n</pre> plots.plot_TvsP(T,P,GFE) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In [22], line 1\n----&gt; 1 plots.plot_TvsP(T,P,GFE)\n\nNameError: name 'plots' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>import numpy as np\npot_1 = np.array([[3,2,1],[4,1,1],[2,1,1]])\npot_2 = np.array([[0,0,2],[0,4,5],[0,4,5]])\n</pre> import numpy as np pot_1 = np.array([[3,2,1],[4,1,1],[2,1,1]]) pot_2 = np.array([[0,0,2],[0,4,5],[0,4,5]]) In\u00a0[\u00a0]: Copied! <pre>plots.plot_TvsP(np.array([0,10,20]),np.array([0,10,20]).transpose(),pot_1,\n                pot_2,material_labels=[\"A\",\"B\"])\n</pre> plots.plot_TvsP(np.array([0,10,20]),np.array([0,10,20]).transpose(),pot_1,                 pot_2,material_labels=[\"A\",\"B\"]) In\u00a0[34]: Copied! <pre>from thermopot import stability\n</pre> from thermopot import stability <pre>\n---------------------------------------------------------------------------\nImportError                               Traceback (most recent call last)\nCell In [34], line 1\n----&gt; 1 from thermopot import stability\n\nImportError: cannot import name 'stability' from 'thermopot' (/Users/prakriti/development/ThermoPot/thermopot/__init__.py)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial/#tutorial","title":"Tutorial\u00b6","text":""},{"location":"tutorial/#introduction","title":"Introduction\u00b6","text":""},{"location":"tutorial/#code-structure","title":"Code structure\u00b6","text":"<p>There are three core classes in ThermoPot:</p> <ol> <li><p>Calculation to store data for a single calculation. For example, an energy calculated using the HSE06 functional)</p> </li> <li><p>Material to store data and make predictions for a single material. For example BaZrS$_3$, with energies calculated at various levels of theory.</p> </li> <li><p>Reaction to store data  and make predictions for a single chemical reaction. For example BaZrS$_3$ -&gt; BaS$_2$ + ZrS</p> </li> </ol> <p>The structure is hierachial; one more <code>Calculation</code> instances are used to build a <code>Material</code> instance, and three or more <code>Material</code> objects are used to calculate a <code>Reaction</code> instance. In addition to this there are is the <code>Potential</code> class to store and plot a single  thermodynamic potential, and the <code>Potentials</code> class to store and plot multiple thermodynamic potentials.</p>"},{"location":"tutorial/#step-1-import-relevant-libraries","title":"Step 1 - import relevant libraries\u00b6","text":""},{"location":"tutorial/#step-2-create-calculations","title":"Step 2 - create <code>calculations</code>\u00b6","text":"<p>There are two ways to create a <code>Calculations</code> object:</p> <ol> <li><p>Manually input the attributes (calculated energy, xc-functional type, volume, number of atoms).</p> </li> <li><p>Parse a FHI-aims output file to read this data automatically. Provide the path for an <code>aims.out</code> file.</p> </li> </ol> <p>We will provide an example for each which uses the <code>vars</code> function to show that the class attributes are equal.</p>"},{"location":"tutorial/#step-3-create-materials","title":"Step 3 - create <code>materials</code>\u00b6","text":""},{"location":"tutorial/#step-4-define-a-reaction","title":"Step 4 - define a <code>reaction</code>\u00b6","text":""}]}