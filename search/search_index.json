{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"============================ Software for ab-initio thermodynamic modelling of material formation and decomposition. \ud83d\udcda The documentation is here . \ud83d\udd04 This code is made available under the GNU General Public Licence (GPL) v3. See the LICENSE file for the full text. \ud83d\udd8a If you use this package for your research please cite accordingly . Please note This work adapts and extends a previous repository developed by Adam Jackson : Thermodynamic model of CZTS .","title":"Welcome"},{"location":"#please-note","text":"This work adapts and extends a previous repository developed by Adam Jackson : Thermodynamic model of CZTS .","title":"Please note"},{"location":"api/","text":"API documentation Bases: object Parent class for parsing and storing data from electronic structure calculations. Source code in thermopot/calculations.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Calculation ( object ): \"\"\"Parent class for parsing and storing data from electronic structure calculations.\"\"\" def __init__ ( self ): \"\"\"All attributes are None until set by derived classes. Attributes: volume (float): volume of the periodic unit cell filepath (str): path to the calculation output files energy (float): DFT total energy in eV xc (str): XC functional used to calculate the total energy. Options are \"hse06\" or \"pbesol\". NAtoms (int): number of atoms in the periodice unit cell Returns: None. \"\"\" self . volume = None self . filepath = None self . energy = None self . xc = None self . NAtoms = None def check_attributes ( self ): \"\"\"Check that the Calculation class attributes make basic sense.\"\"\" assert type ( self . filepath ) == str , \"filepath must be a string\" assert type ( self . energy ) == float , \"energy must be a float\" assert type ( self . xc ) == str , \"xc must be a string\" assert ( type ( self . NAtoms ) == int ) and self . NAtoms >= 1 , \"NAtoms must be an integer >= 1\" assert ( type ( self . volume ) == float ) and self . volume > 0 , \"volume must be a float > 0\" __init__ () All attributes are None until set by derived classes. Attributes: Name Type Description volume float volume of the periodic unit cell filepath str path to the calculation output files energy float DFT total energy in eV xc str XC functional used to calculate the total energy. Options are \"hse06\" or \"pbesol\". NAtoms int number of atoms in the periodice unit cell Returns: Type Description None. Source code in thermopot/calculations.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def __init__ ( self ): \"\"\"All attributes are None until set by derived classes. Attributes: volume (float): volume of the periodic unit cell filepath (str): path to the calculation output files energy (float): DFT total energy in eV xc (str): XC functional used to calculate the total energy. Options are \"hse06\" or \"pbesol\". NAtoms (int): number of atoms in the periodice unit cell Returns: None. \"\"\" self . volume = None self . filepath = None self . energy = None self . xc = None self . NAtoms = None check_attributes () Check that the Calculation class attributes make basic sense. Source code in thermopot/calculations.py 27 28 29 30 31 32 33 34 35 36 37 38 def check_attributes ( self ): \"\"\"Check that the Calculation class attributes make basic sense.\"\"\" assert type ( self . filepath ) == str , \"filepath must be a string\" assert type ( self . energy ) == float , \"energy must be a float\" assert type ( self . xc ) == str , \"xc must be a string\" assert ( type ( self . NAtoms ) == int ) and self . NAtoms >= 1 , \"NAtoms must be an integer >= 1\" assert ( type ( self . volume ) == float ) and self . volume > 0 , \"volume must be a float > 0\" Bases: Calculation Class for parsing and storing data from a FHI-AIMS total energy calculation. Source code in thermopot/calculations.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class AimsCalculation ( Calculation ): \"\"\"Class for parsing and storing data from a FHI-AIMS total energy calculation.\"\"\" def __init__ ( self , filepath = \"./calculation.out\" ): \"\"\" Args: filepath: path to the calculation output files \"\"\" super () . __init__ () self . filepath = filepath self . volume = self . get_volume () self . energy = self . get_energy () self . xc = self . get_xc () self . NAtoms = self . get_NAtoms () def get_volume ( self ): with open ( self . filepath ) as contents : return float ( re . findall ( \"Unit cell volume\\s+:\\s*(.*)\\sA\" , contents . read ())[ - 1 ] ) def get_energy ( self ): with open ( self . filepath ) as contents : return float ( re . findall ( \"Total energy of the DFT[^0-9]+(-\\d*\\.?\\d*) eV\" , contents . read () )[ - 1 ] ) def get_xc ( self ): with open ( self . filepath ) as contents : return re . findall ( \"xc\\s+(\\S+)\" , contents . read ())[ - 1 ] def get_NAtoms ( self ): with open ( self . filepath ) as contents : return int ( re . findall ( \"Number of atoms\\s +:\\s + (\\S+)\" , contents . read ())[ - 1 ] ) __init__ ( filepath = './calculation.out' ) Parameters: Name Type Description Default filepath path to the calculation output files './calculation.out' Source code in thermopot/calculations.py 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , filepath = \"./calculation.out\" ): \"\"\" Args: filepath: path to the calculation output files \"\"\" super () . __init__ () self . filepath = filepath self . volume = self . get_volume () self . energy = self . get_energy () self . xc = self . get_xc () self . NAtoms = self . get_NAtoms () Bases: object Parent class for materials properties. See docstrings for derived classes solid, ideal_gas Source code in thermopot/materials.py 20 21 22 23 24 25 26 27 28 29 class Material ( object ): \"\"\"Parent class for materials properties. See docstrings for derived classes solid, ideal_gas\"\"\" def __init__ ( self , name , stoichiometry , energies ): self . name = name self . stoichiometry = stoichiometry self . energies = energies self . N = sum ( self . stoichiometry . values ()) Bases: Material Class for solid material data. Sets properties: solid.name (Identifying string) solid.stoichiometry (Dict relating element to number of atoms in a single formula unit) solid.energies (Dict relating xc functional to DFT total energy in eV) solid.fu_cell (Number of formula units in periodic unit cell) solid.volume (Volume of unit cell in cubic angstroms (m3 * 10^30)) solid.phonons (String containing path to phonopy-FHI-aims output data file) solid.N (Number of atoms per formula unit) solid.NAtoms (Number of atoms in periodic unit cell) Sets methods: solid.U_eV(T), solid.U_J(T), solid.U_kJ(T) : Internal energy solid.H_eV(T,P), solid.H_J(T,P), solid.H_kJ(T,P) : Enthalpy H = U + PV solid.mu_eV(T,P), solid.mu_J(T,P), solid.mu_kJ(T,P) : Chemical potential mu = U + PV - TS The material is assumed to be incompressible and without thermal expansion Source code in thermopot/materials.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 class Solid ( Material ): \"\"\" Class for solid material data. Sets properties: ------------------- solid.name (Identifying string) solid.stoichiometry (Dict relating element to number of atoms in a single formula unit) solid.energies (Dict relating xc functional to DFT total energy in eV) solid.fu_cell (Number of formula units in periodic unit cell) solid.volume (Volume of unit cell in cubic angstroms (m3 * 10^30)) solid.phonons (String containing path to phonopy-FHI-aims output data file) solid.N (Number of atoms per formula unit) solid.NAtoms (Number of atoms in periodic unit cell) Sets methods: ------------------- solid.U_eV(T), solid.U_J(T), solid.U_kJ(T) : Internal energy solid.H_eV(T,P), solid.H_J(T,P), solid.H_kJ(T,P) : Enthalpy H = U + PV solid.mu_eV(T,P), solid.mu_J(T,P), solid.mu_kJ(T,P) : Chemical potential mu = U + PV - TS The material is assumed to be incompressible and without thermal expansion \"\"\" def __init__ ( self , name , stoichiometry , phonon_filepath , calculation = False , volume = False , energies = False , NAtoms = 1 , ): if calculation is not False : Material . __init__ ( self , name , stoichiometry , { calculation . xc : calculation . energy } ) self . volume = calculation . volume self . NAtoms = calculation . NAtoms else : Material . __init__ ( self , name , stoichiometry , energies ) self . NAtoms = NAtoms self . volume = volume self . fu_cell = self . NAtoms / self . N self . phonons = materials_directory + phonon_filepath # TODO: allow calculations without giving phonons def U_eV ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one formula unit of solid, expressed in eV. U = solid.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" U_func = interpolate . get_potential_aims ( self . phonons , \"U\" ) E_dft = self . energies [ xc ] return ( E_dft + U_func ( T )) / self . fu_cell def U_J ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of solid, expressed in J/mol U = solid.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return ( self . U_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def U_kJ ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of solid, expressed in kJ/mol U = solid.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return self . U_J ( T , xc = xc ) / 1000.0 def H_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Enthalpy of one formula unit of solid, expressed in eV H = solid.H_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" U_func = interpolate . get_potential_aims ( self . phonons , \"U\" ) PV = ( P * self . volume * 1e-30 * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) E_dft = self . energies [ xc ] return (( E_dft + U_func ( T )) + PV ) / self . fu_cell def H_J ( self , T , P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of solid, expressed in J/mol H = solid.H_J(T,P) T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . H_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def H_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of solid, expressed in kJ/mol H = solid.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . H_J ( T , P , xc = xc ) * 0.001 def mu_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one formula unit of solid, expressed in eV mu = solid.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" TS_func = interpolate . get_potential_aims ( self . phonons , \"TS\" ) H = self . H_eV ( T , P , xc = xc ) return H - TS_func ( T ) / self . fu_cell def mu_J ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of solid, expressed in J/mol mu = solid.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . mu_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def mu_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of solid, expressed in kJ/mol mu = solid.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . mu_J ( T , P , xc = xc ) * 0.001 def Cv_kB ( self , T ): \"\"\" Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_kB(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" Cv_func = interpolate . get_potential_aims ( self . phonons , \"Cv\" ) return Cv_func ( T ) / self . fu_cell def Cv_eV ( self , T ): \"\"\" Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_eV(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return ( self . Cv_kB ( T ) * constants . physical_constants [ \"Boltzmann constant in eV/K\" ][ 0 ] ) def Cv_J ( self , T ): \"\"\" Constant-volume heat capacity of solid, expressed in J/molK. Cv = solid.Cv_J(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return ( self . Cv_kB ( T ) * constants . physical_constants [ \"Boltzmann constant\" ][ 0 ] * constants . N_A ) def Cv_kJ ( self , T ): \"\"\" Constant-volume heat capacity of solid, expressed in kJ/molK. Cv = solid.Cv_kJ(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return self . Cv_J ( T ) * 0.001 Cv_J ( T ) Constant-volume heat capacity of solid, expressed in J/molK. Cv = solid.Cv_J(T) T may be an array, in which case Cv will be an array of the same dimensions. Source code in thermopot/materials.py 268 269 270 271 272 273 274 275 276 277 278 def Cv_J ( self , T ): \"\"\" Constant-volume heat capacity of solid, expressed in J/molK. Cv = solid.Cv_J(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return ( self . Cv_kB ( T ) * constants . physical_constants [ \"Boltzmann constant\" ][ 0 ] * constants . N_A ) Cv_eV ( T ) Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_eV(T) T may be an array, in which case Cv will be an array of the same dimensions. Source code in thermopot/materials.py 256 257 258 259 260 261 262 263 264 265 266 def Cv_eV ( self , T ): \"\"\" Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_eV(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return ( self . Cv_kB ( T ) * constants . physical_constants [ \"Boltzmann constant in eV/K\" ][ 0 ] ) Cv_kB ( T ) Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_kB(T) T may be an array, in which case Cv will be an array of the same dimensions. Source code in thermopot/materials.py 246 247 248 249 250 251 252 253 254 def Cv_kB ( self , T ): \"\"\" Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_kB(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" Cv_func = interpolate . get_potential_aims ( self . phonons , \"Cv\" ) return Cv_func ( T ) / self . fu_cell Cv_kJ ( T ) Constant-volume heat capacity of solid, expressed in kJ/molK. Cv = solid.Cv_kJ(T) T may be an array, in which case Cv will be an array of the same dimensions. Source code in thermopot/materials.py 280 281 282 283 284 285 286 def Cv_kJ ( self , T ): \"\"\" Constant-volume heat capacity of solid, expressed in kJ/molK. Cv = solid.Cv_kJ(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return self . Cv_J ( T ) * 0.001 H_J ( T , P , xc = 'pbesol' ) Enthalpy of one gram-mole of solid, expressed in J/mol H = solid.H_J(T,P) T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def H_J ( self , T , P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of solid, expressed in J/mol H = solid.H_J(T,P) T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . H_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) H_eV ( T , P , xc = 'pbesol' ) Enthalpy of one formula unit of solid, expressed in eV H = solid.H_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def H_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Enthalpy of one formula unit of solid, expressed in eV H = solid.H_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" U_func = interpolate . get_potential_aims ( self . phonons , \"U\" ) PV = ( P * self . volume * 1e-30 * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) E_dft = self . energies [ xc ] return (( E_dft + U_func ( T )) + PV ) / self . fu_cell H_kJ ( T , P , xc = 'pbesol' ) Enthalpy of one gram-mole of solid, expressed in kJ/mol H = solid.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def H_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of solid, expressed in kJ/mol H = solid.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . H_J ( T , P , xc = xc ) * 0.001 U_J ( T , xc = 'pbesol' ) Internal energy of one gram-mole of solid, expressed in J/mol U = solid.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 97 98 99 100 101 102 103 104 105 106 107 108 109 def U_J ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of solid, expressed in J/mol U = solid.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return ( self . U_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) U_eV ( T , xc = 'pbesol' ) Internal energy of one formula unit of solid, expressed in eV. U = solid.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 85 86 87 88 89 90 91 92 93 94 95 def U_eV ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one formula unit of solid, expressed in eV. U = solid.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" U_func = interpolate . get_potential_aims ( self . phonons , \"U\" ) E_dft = self . energies [ xc ] return ( E_dft + U_func ( T )) / self . fu_cell U_kJ ( T , xc = 'pbesol' ) Internal energy of one gram-mole of solid, expressed in kJ/mol U = solid.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 111 112 113 114 115 116 117 118 119 def U_kJ ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of solid, expressed in kJ/mol U = solid.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return self . U_J ( T , xc = xc ) / 1000.0 mu_J ( T , P , xc = 'pbesol' ) Free energy of one mol of solid, expressed in J/mol mu = solid.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def mu_J ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of solid, expressed in J/mol mu = solid.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . mu_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) mu_eV ( T , P , xc = 'pbesol' ) Free energy of one formula unit of solid, expressed in eV mu = solid.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def mu_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one formula unit of solid, expressed in eV mu = solid.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" TS_func = interpolate . get_potential_aims ( self . phonons , \"TS\" ) H = self . H_eV ( T , P , xc = xc ) return H - TS_func ( T ) / self . fu_cell mu_kJ ( T , P , xc = 'pbesol' ) Free energy of one mol of solid, expressed in kJ/mol mu = solid.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def mu_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of solid, expressed in kJ/mol mu = solid.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . mu_J ( T , P , xc = xc ) * 0.001 Bases: Material Class for ideal gas properties. Sets properties: ideal_gas.name (string) ideal_gas.stoichiometry (Dict relating element to number of atoms in a single formula unit) ideal_gas.energies (Dict relating xc functional with DFT total energy) ideal_gas.thermo_data (String containing path to aims.vibrations output data file) ideal_gas.N (Number of atoms per formula unit) Sets methods: ideal_gas.U_eV(T), ideal_gas.U_J(T), ideal_gas.U_kJ(T) : Internal energy ideal_gas.H_eV(T), ideal_gas.H_J(T), ideal_gas.H_kJ(T) : Enthalpy H = U + PV ideal_gas.mu_eV(T,P), ideal_gas.mu_J(T,P), ideal_gas.mu_kJ(T,P) : Chemical potential mu = U + PV - TS Ideal gas law PV=nRT is applied: specifically (dH/dP) at const. T = 0 and int(mu)^P2_P1 dP = kTln(P2/P1) Enthalpy has no P dependence as volume is not restricted / expansion step is defined as isothermal Source code in thermopot/materials.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 class IdealGas ( Material ): \"\"\" Class for ideal gas properties. Sets properties: ------------------- ideal_gas.name (string) ideal_gas.stoichiometry (Dict relating element to number of atoms in a single formula unit) ideal_gas.energies (Dict relating xc functional with DFT total energy) ideal_gas.thermo_data (String containing path to aims.vibrations output data file) ideal_gas.N (Number of atoms per formula unit) Sets methods: ------------------- ideal_gas.U_eV(T), ideal_gas.U_J(T), ideal_gas.U_kJ(T) : Internal energy ideal_gas.H_eV(T), ideal_gas.H_J(T), ideal_gas.H_kJ(T) : Enthalpy H = U + PV ideal_gas.mu_eV(T,P), ideal_gas.mu_J(T,P), ideal_gas.mu_kJ(T,P) : Chemical potential mu = U + PV - TS Ideal gas law PV=nRT is applied: specifically (dH/dP) at const. T = 0 and int(mu)^P2_P1 dP = kTln(P2/P1) Enthalpy has no P dependence as volume is not restricted / expansion step is defined as isothermal \"\"\" # TODO:script for calculating zpe values def __init__ ( self , name , stoichiometry , thermo_file , calculation = False , energies = False , zpe_pbesol = 0 , zpe_hse06 = 0 , zpe_lit = 0 , ): if calculation is not False : Material . __init__ ( self , name , stoichiometry , { calculation . xc : calculation . energy } ) else : Material . __init__ ( self , name , stoichiometry , energies ) self . thermo_file = materials_directory + thermo_file # Initialise ZPE to HSE06 value if provided. # This looks redundant at the moment: the intent is to implement # some kind of switch or heirarchy of methods further down the line. if zpe_hse06 > 0 : self . zpe = zpe_pbesol elif zpe_pbesol > 0 : self . zpe = zpe_pbesol elif zpe_lit > 0 : self . zpe = zpe_lit else : self . zpe = 0 def U_eV ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one formula unit of ideal gas, expressed in eV. U = ideal_gas.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" U_func = interpolate . get_potential_nist_table ( self . thermo_file , \"U\" ) E_dft = self . energies [ xc ] return ( E_dft + self . zpe + U_func ( T ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) def U_J ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of ideal gas, expressed in J/mol U = ideal_gas.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return ( self . U_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def U_kJ ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of ideal gas, expressed in kJ/mol U = ideal_gas.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return self . U_J ( T , xc = xc ) * 0.001 def H_eV ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one formula unit of ideal gas, expressed in eV H = ideal_gas.H_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" H_func = interpolate . get_potential_nist_table ( self . thermo_file , \"H\" ) E_dft = self . energies [ xc ] return ( E_dft + self . zpe + H_func ( T , xc = xc ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) def H_J ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of ideal gas, expressed in J/mol H = ideal_gas.H_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" return ( self . H_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def H_kJ ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of ideal gas, expressed in kJ/mol H = ideal_gas.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" return self . H_J ( T , xc = xc ) * 0.001 def mu_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one formula unit of ideal gas, expressed in eV mu = ideal_gas.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" S_func = interpolate . get_potential_nist_table ( self . thermo_file , \"S\" ) S = ( S_func ( T ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) H = self . H_eV ( T , xc = xc ) return ( H - T * S + constants . physical_constants [ \"Boltzmann constant in eV/K\" ][ 0 ] * T * np . log ( P / 1e5 ) ) def mu_J ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of ideal gas, expressed in J/mol mu = ideal_gas.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . mu_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def mu_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of ideal gas, expressed in kJ/mol mu = ideal_gas.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . mu_J ( T , P , xc = xc ) * 0.001 H_J ( T , * P , xc = 'pbesol' ) Enthalpy of one gram-mole of ideal gas, expressed in J/mol H = ideal_gas.H_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused Source code in thermopot/materials.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 def H_J ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of ideal gas, expressed in J/mol H = ideal_gas.H_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" return ( self . H_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) H_eV ( T , * P , xc = 'pbesol' ) Enthalpy of one formula unit of ideal gas, expressed in eV H = ideal_gas.H_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused Source code in thermopot/materials.py 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def H_eV ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one formula unit of ideal gas, expressed in eV H = ideal_gas.H_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" H_func = interpolate . get_potential_nist_table ( self . thermo_file , \"H\" ) E_dft = self . energies [ xc ] return ( E_dft + self . zpe + H_func ( T , xc = xc ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) H_kJ ( T , * P , xc = 'pbesol' ) Enthalpy of one gram-mole of ideal gas, expressed in kJ/mol H = ideal_gas.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused Source code in thermopot/materials.py 428 429 430 431 432 433 434 435 436 437 438 439 def H_kJ ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of ideal gas, expressed in kJ/mol H = ideal_gas.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" return self . H_J ( T , xc = xc ) * 0.001 U_J ( T , xc = 'pbesol' ) Internal energy of one gram-mole of ideal gas, expressed in J/mol U = ideal_gas.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def U_J ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of ideal gas, expressed in J/mol U = ideal_gas.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return ( self . U_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) U_eV ( T , xc = 'pbesol' ) Internal energy of one formula unit of ideal gas, expressed in eV. U = ideal_gas.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def U_eV ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one formula unit of ideal gas, expressed in eV. U = ideal_gas.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" U_func = interpolate . get_potential_nist_table ( self . thermo_file , \"U\" ) E_dft = self . energies [ xc ] return ( E_dft + self . zpe + U_func ( T ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) U_kJ ( T , xc = 'pbesol' ) Internal energy of one gram-mole of ideal gas, expressed in kJ/mol U = ideal_gas.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 379 380 381 382 383 384 385 386 387 388 def U_kJ ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of ideal gas, expressed in kJ/mol U = ideal_gas.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return self . U_J ( T , xc = xc ) * 0.001 mu_J ( T , P , xc = 'pbesol' ) Free energy of one mol of ideal gas, expressed in J/mol mu = ideal_gas.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def mu_J ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of ideal gas, expressed in J/mol mu = ideal_gas.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . mu_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) mu_eV ( T , P , xc = 'pbesol' ) Free energy of one formula unit of ideal gas, expressed in eV mu = ideal_gas.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def mu_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one formula unit of ideal gas, expressed in eV mu = ideal_gas.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" S_func = interpolate . get_potential_nist_table ( self . thermo_file , \"S\" ) S = ( S_func ( T ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) H = self . H_eV ( T , xc = xc ) return ( H - T * S + constants . physical_constants [ \"Boltzmann constant in eV/K\" ][ 0 ] * T * np . log ( P / 1e5 ) ) mu_kJ ( T , P , xc = 'pbesol' ) Free energy of one mol of ideal gas, expressed in kJ/mol mu = ideal_gas.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def mu_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of ideal gas, expressed in kJ/mol mu = ideal_gas.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . mu_J ( T , P , xc = xc ) * 0.001 Bases: object Class for calculated sulfur equilibria. Sets properties: sulfur_model.name (string) sulfur_model.pbesol_energy_eV (DFT total energy in eV with PBEsol XC functional for D4d S8 cluster) sulfur_model.thermo_data (String containing path to T/P effects data file) sulfur_model.N (Number of atoms per formula unit) sulfur_model.N_ref (Number of atoms per formula unit of reference state) Sets methods: sulfur_model.mu_eV(T,P), sulfur_model.mu_J(T,P), sulfur_model.mu_kJ(T,P) : Chemical potential mu = U + PV - TS Ideal gas law PV=nRT is applied: specifically (dH/dP) at const. T = 0 and int(mu)^P2_P1 dP = kTln(P2/P1) Methods not yet implemented: sulfur_model.U_eV(T), sulfur_model.U_J(T), sulfur_model.U_kJ(T) : Internal energy sulfur_model.H_eV(T), sulfur_model.H_J(T), sulfur_model.H_kJ(T) : Enthalpy H = U + PV Thermo data file format: CSV file containing header line: T/K, mu (x1 Pa) / J mol-1,mu (x2 Pa) / J mol-1... followed by comma-separated data rows t1,mu11,mu12 ... t2,mu21,mu22 ... ... DEV NOTE: Not currently a derived class of \"material\" due to substantially different operation. Source code in thermopot/materials.py 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 class SulfurModel ( object ): \"\"\" Class for calculated sulfur equilibria. Sets properties: ------------------- sulfur_model.name (string) sulfur_model.pbesol_energy_eV (DFT total energy in eV with PBEsol XC functional for D4d S8 cluster) sulfur_model.thermo_data (String containing path to T/P effects data file) sulfur_model.N (Number of atoms per formula unit) sulfur_model.N_ref (Number of atoms per formula unit of reference state) Sets methods: ------------------- sulfur_model.mu_eV(T,P), sulfur_model.mu_J(T,P), sulfur_model.mu_kJ(T,P) : Chemical potential mu = U + PV - TS Ideal gas law PV=nRT is applied: specifically (dH/dP) at const. T = 0 and int(mu)^P2_P1 dP = kTln(P2/P1) Methods not yet implemented: ---------------------------- sulfur_model.U_eV(T), sulfur_model.U_J(T), sulfur_model.U_kJ(T) : Internal energy sulfur_model.H_eV(T), sulfur_model.H_J(T), sulfur_model.H_kJ(T) : Enthalpy H = U + PV Thermo data file format: ------------------------ CSV file containing header line: # T/K, mu (x1 Pa) / J mol-1,mu (x2 Pa) / J mol-1... followed by comma-separated data rows t1,mu11,mu12 ... t2,mu21,mu22 ... ... DEV NOTE: --------- Not currently a derived class of \"material\" due to substantially different operation. \"\"\" # TODO: generalise this for other nist data? def __init__ ( self , name , pbesol_energy_eV , mu_file , N = 1 , N_ref = 8 ): self . name = name self . stoichiometry = { \"S\" : 1 } self . pbesol_energy_eV = pbesol_energy_eV self . mu_file = materials_directory + mu_file self . N = 1 self . N_ref = N_ref self . _mu_tab = interpolate . get_potential_sulfur_table ( self . mu_file ) def mu_J ( self , T , P ): if type ( T ) == np . ndarray : T = T . flatten () if type ( P ) == np . ndarray : P = P . flatten () E0 = self . pbesol_energy_eV * eV2Jmol return self . _mu_tab ( T , P ) + E0 / self . N_ref def mu_kJ ( self , T , P ): return self . mu_J ( T , P ) * 1e-3 def mu_eV ( self , T , P ): return self . mu_J ( T , P ) / eV2Jmol Class for reaction data Sets properties: reaction.reactants (Dict relating reactant materials to a number of formula units) reaction.products (Dict relating product materials to a number of formular units) Sets methods: reaction.DH_eV_pbesol(T,P), reaction.DH_kJ_pbesol(T,P), reaction.DH_eV_hse06(T,P), reaction.DH_kJ_hse06(T,P) : Enthalpy of formation reaction.DU_eV_pbesol(T,P), reaction.DU_kJ_pbesol(T,P), reaction.DU_eV_hse06(T,P), reaction.DU_kJ_hse06(T,P) : Internal energy change reaction.Dmu_eV_pbesol(T,P), reaction.Dmu_kJ_pbesol(T,P), reaction.Dmu_eV_hse06(T,P), reaction.Dmu_kJ_hse06(T,P) : Gibbs free energy of formation Source code in thermopot/reactions.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class Reaction : \"\"\" Class for reaction data Sets properties: ------------------- reaction.reactants (Dict relating reactant materials to a number of formula units) reaction.products (Dict relating product materials to a number of formular units) Sets methods: ------------------- reaction.DH_eV_pbesol(T,P), reaction.DH_kJ_pbesol(T,P), reaction.DH_eV_hse06(T,P), reaction.DH_kJ_hse06(T,P) : Enthalpy of formation reaction.DU_eV_pbesol(T,P), reaction.DU_kJ_pbesol(T,P), reaction.DU_eV_hse06(T,P), reaction.DU_kJ_hse06(T,P) : Internal energy change reaction.Dmu_eV_pbesol(T,P), reaction.Dmu_kJ_pbesol(T,P), reaction.Dmu_eV_hse06(T,P), reaction.Dmu_kJ_hse06(T,P) : Gibbs free energy of formation \"\"\" def __init__ ( self , reactants_dictionary , products_dictionary , temperature = 298.15 , pressure = 1e5 , ): \"\"\" reactants_dictionary and products dictionary takes the form { class_instance : formula units } and can have an arbitrary number of key-value pairs. `Class instance` is an instance of the `materials.solid` or `materials.ideal_gas` classes. temperature is provided in kelvin, pressure is provided in Pa. \"\"\" self . reactants = reactants_dictionary self . products = products_dictionary self . T = temperature self . P = pressure def DH_eV_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_enthalpy , products_enthalpy = 0 , 0 for material , fu in self . reactants . items (): reactants_enthalpy += material . H_eV ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_enthalpy += material . H_eV ( T , P , xc = \"pbesol\" ) * fu return products_enthalpy - reactants_enthalpy def DH_kJ_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_enthalpy , products_enthalpy = 0 , 0 for material , fu in self . reactants . items (): reactants_enthalpy += material . H_kJ ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_enthalpy += material . H_kJ ( T , P , xc = \"pbesol\" ) * fu return products_enthalpy - reactants_enthalpy def DH_eV_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_enthalpy , products_enthalpy = 0 , 0 for material , fu in self . reactants . items (): reactants_enthalpy += material . H_eV ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_enthalpy += material . H_eV ( T , P , xc = \"hse06\" ) * fu return products_enthalpy - reactants_enthalpy def DH_kJ_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_enthalpy , products_enthalpy = 0 , 0 for material , fu in self . reactants . items (): reactants_enthalpy += material . H_kJ ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_enthalpy += material . H_kJ ( T , P , xc = \"hse06\" ) * fu return products_enthalpy - reactants_enthalpy def DU_eV_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . U_eV ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_energy += material . U_eV ( T , P , xc = \"pbesol\" ) * fu return products_energy - reactants_energy def DU_kJ_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . U_kJ ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_energy += material . U_kJ ( T , P , xc = \"pbesol\" ) * fu return products_energy - reactants_energy def DU_eV_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . U_eV ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_energy += material . U_eV ( T , P , xc = \"hse06\" ) * fu return products_energy - reactants_energy def DU_kJ_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . U_kJ ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_energy += material . U_kJ ( T , P , xc = \"hse06\" ) * fu return products_energy - reactants_energy def Dmu_eV_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . mu_eV ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_energy += material . mu_eV ( T , P , xc = \"pbesol\" ) * fu return products_energy - reactants_energy def Dmu_kJ_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . mu_kJ ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_energy += material . mu_kJ ( T , P , xc = \"pbesol\" ) * fu return products_energy - reactants_energy def Dmu_eV_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . mu_eV ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_energy += material . mu_eV ( T , P , xc = \"hse06\" ) * fu return products_energy - reactants_energy def Dmu_kJ_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . mu_kJ ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_energy += material . mu_kJ ( T , P , xc = \"hse06\" ) * fu return products_energy - reactants_energy __init__ ( reactants_dictionary , products_dictionary , temperature = 298.15 , pressure = 100000.0 ) reactants_dictionary and products dictionary takes the form { class_instance : formula units } and can have an arbitrary number of key-value pairs. Class instance is an instance of the materials.solid or materials.ideal_gas classes. temperature is provided in kelvin, pressure is provided in Pa. Source code in thermopot/reactions.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def __init__ ( self , reactants_dictionary , products_dictionary , temperature = 298.15 , pressure = 1e5 , ): \"\"\" reactants_dictionary and products dictionary takes the form { class_instance : formula units } and can have an arbitrary number of key-value pairs. `Class instance` is an instance of the `materials.solid` or `materials.ideal_gas` classes. temperature is provided in kelvin, pressure is provided in Pa. \"\"\" self . reactants = reactants_dictionary self . products = products_dictionary self . T = temperature self . P = pressure Thermodynamic property interpolation function. Requires phonopy-FHI-aims output file. Reads data for S and Cv expressed in J/K/mol, F and U in kJ/mol. Outputs data for S and Cv in kB/cell, U, F and TS in eV/cell. Source code in thermopot/interpolate.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def get_potential_aims ( file , property ): \"\"\"Thermodynamic property interpolation function. Requires phonopy-FHI-aims output file. Reads data for S and Cv expressed in J/K/mol, F and U in kJ/mol. Outputs data for S and Cv in kB/cell, U, F and TS in eV/cell. \"\"\" data = genfromtxt ( file ) T = data [:, 0 ] if property in ( \"Cv\" , \"Cp\" , \"heat_capacity\" , \"C\" ): potential = data [:, 3 ] / kB2JKmol elif property in ( \"U\" , \"internal_energy\" ): potential = data [:, 4 ] / eV2kJmol elif property in ( \"F\" , \"A\" , \"Helmholtz\" , \"free_energy\" ): potential = data [:, 1 ] / eV2kJmol elif property in ( \"S\" , \"Entropy\" , \"entropy\" ): potential = data [:, 2 ] / kB2JKmol elif property in ( \"TS\" ): potential = T * data [:, 2 ] else : raise RuntimeError ( \"Property not found\" ) thefunction = interp1d ( T , potential , kind = \"linear\" ) return thefunction Thermodynamic property interpolation function. Requires NIST-JANAF table. All properties in J, mol and K Source code in thermopot/interpolate.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def get_potential_nist_table ( file , property ): \"\"\"Thermodynamic property interpolation function. Requires NIST-JANAF table. All properties in J, mol and K\"\"\" data = genfromtxt ( file , skip_header = 2 ) T = data [:, 0 ] if property in ( \"Cp\" , \"C\" , \"heat_capacity\" ): potential = data [:, 1 ] elif property in ( \"S\" , \"entropy\" ): potential = data [:, 2 ] elif property in ( \"H\" , \"enthalpy\" ): potential = ( data [:, 4 ] - data [ 0 , 4 ]) * 1e3 elif property in ( \"U\" , \"internal_energy\" ): # U = H - PV; for ideal gas molar PV = RT so U = H - RT from scipy.constants import R as R potential = ( data [:, 4 ] - data [ 0 , 4 ]) * 1e3 - R * data [:, 0 ] elif property in ( \"DH\" , \"Delta_H\" , \"standard_enthalpy_change\" ): potential = data [:, 4 ] * 1e3 else : raise RuntimeError ( \"Property not found\" ) thefunction = interp1d ( T , potential , kind = \"cubic\" ) return thefunction Read thermodynamic property as function of T, P from datafile. Datafile should be generated by the code at http://github.com/WMD-bath/sulfur-model or follow the same format Source code in thermopot/interpolate.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def get_potential_sulfur_table ( filename ): \"\"\" Read thermodynamic property as function of T, P from datafile. Datafile should be generated by the code at http://github.com/WMD-bath/sulfur-model or follow the same format \"\"\" # Import chemical potential in J mol-1 vs T, P from file data = genfromtxt ( filename , comments = \"#\" , delimiter = \",\" ) T = data [:, 0 ] . flatten () with open ( filename , \"r\" ) as f : header = f . readline () P = [ float ( p ) for p in re . findall ( r \"\\d+.\\d+\" , header )] thefunction = interp2d ( T , np . log ( P ), data [:, 1 :] . transpose (), kind = \"cubic\" ) def lin_P_function ( T , P ): return thefunction ( T , np . log ( P )) return lin_P_function T is an array e.g. np.linspace(100, 1500, 100) # K P is an array orthogonal to T. e.g. np.array(np.logspace(1, 7, 100), ndmin=2).transpose() # Pa potential is returned from a reactions.reaction method called for an instance with attributes T,P. If T has length m and P has length n, P will be a 2D array with dimensions m x n. e.g. reactions.reaction({Ba:1,S:2}, {BaS2:1}},temperature=T,pressure=P).Dmu_eV_pbesol() potential_label is the label of the contour colorbar e.g. '$\\Delta G_f$ / kJ mol$^{-1}$' scale_range is the scale of the colorbar e.g. [-380, -240] filename is the output filename e.g. 'plots/Dmu-BaS2-Ba-S2.png'. If not provided plt.show() is called. Source code in thermopot/plots.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def plot_TvsP ( T , P , * potential , potential_label = \"$\\Delta G_f$ / kJ mol$^{-1}$\" , scale_range = [ - 600 , 0 ], filename = False , precision = \" %d \" , T_units = \"K\" , P_units = \"Pa\" ): \"\"\" T is an array e.g. np.linspace(100, 1500, 100) # K P is an array orthogonal to T. e.g. np.array(np.logspace(1, 7, 100), ndmin=2).transpose() # Pa potential is returned from a reactions.reaction method called for an instance with attributes T,P. If T has length m and P has length n, P will be a 2D array with dimensions m x n. e.g. reactions.reaction({Ba:1,S:2}, {BaS2:1}},temperature=T,pressure=P).Dmu_eV_pbesol() potential_label is the label of the contour colorbar e.g. '$\\Delta G_f$ / kJ mol$^{-1}$' scale_range is the scale of the colorbar e.g. [-380, -240] filename is the output filename e.g. 'plots/Dmu-BaS2-Ba-S2.png'. If not provided `plt.show()` is called. \"\"\" mpl . rcParams [ \"font.family\" ] = \"serif\" mpl . rcParams [ \"font.serif\" ] = \"Times New Roman\" mpl . rcParams [ \"font.size\" ] = 16 # Unit conversions (all calculations are in SI units, conversion needed for plots) if T_units == \"K\" : x_values = T x_unitlabel = \"K\" elif T_units == \"C\" : x_values = T - 273.15 x_unitlabel = \"$^\\circ$ C\" else : raise ValueError ( \"Invalid temperature unit: {0} \" . format ( T_units )) if P_units == \"Pa\" : y_values = P . flatten () elif P_units == \"Bar\" or P_units == \"bar\" : y_values = P . flatten () * 1e-5 elif P_units == \"mbar\" : y_values = P . flatten () * 1e-5 * 1e3 elif P_units == \"kPa\" : y_values = P . flatten () * 1e-3 elif P_units == \"mmHg\" or P_units == \"torr\" : y_values = P . flatten () * 760 / ( 1.01325e5 ) else : raise ValueError ( \"Invalid pressure unit: {0} .\" . format ( T_units )) if len ( potential ) == 1 : potential = potential else : find_potentials_minimum ( potential ) fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 ) a = plt . contour ( x_values , y_values , potential , 10 , linewidths = 1 , colors = \"k\" ) plt . pcolormesh ( x_values , y_values , potential , cmap = plt . get_cmap ( \"summer\" ), vmin = scale_range [ 0 ], vmax = scale_range [ 1 ], ) colours = plt . colorbar () plt . xlabel ( \"Temperature / {0} \" . format ( x_unitlabel )) plt . ylabel ( \"Pressure / {0} \" . format ( P_units )) colours . set_label ( potential_label , labelpad = 20 ) ax . set_yscale ( \"log\" ) plt . clabel ( a , fmt = precision ) if filename : plt . savefig ( filename , dpi = 200 ) else : plt . show ()","title":"API"},{"location":"api/#api-documentation","text":"Bases: object Parent class for parsing and storing data from electronic structure calculations. Source code in thermopot/calculations.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Calculation ( object ): \"\"\"Parent class for parsing and storing data from electronic structure calculations.\"\"\" def __init__ ( self ): \"\"\"All attributes are None until set by derived classes. Attributes: volume (float): volume of the periodic unit cell filepath (str): path to the calculation output files energy (float): DFT total energy in eV xc (str): XC functional used to calculate the total energy. Options are \"hse06\" or \"pbesol\". NAtoms (int): number of atoms in the periodice unit cell Returns: None. \"\"\" self . volume = None self . filepath = None self . energy = None self . xc = None self . NAtoms = None def check_attributes ( self ): \"\"\"Check that the Calculation class attributes make basic sense.\"\"\" assert type ( self . filepath ) == str , \"filepath must be a string\" assert type ( self . energy ) == float , \"energy must be a float\" assert type ( self . xc ) == str , \"xc must be a string\" assert ( type ( self . NAtoms ) == int ) and self . NAtoms >= 1 , \"NAtoms must be an integer >= 1\" assert ( type ( self . volume ) == float ) and self . volume > 0 , \"volume must be a float > 0\"","title":"API documentation"},{"location":"api/#thermopot.calculations.Calculation.__init__","text":"All attributes are None until set by derived classes. Attributes: Name Type Description volume float volume of the periodic unit cell filepath str path to the calculation output files energy float DFT total energy in eV xc str XC functional used to calculate the total energy. Options are \"hse06\" or \"pbesol\". NAtoms int number of atoms in the periodice unit cell Returns: Type Description None. Source code in thermopot/calculations.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def __init__ ( self ): \"\"\"All attributes are None until set by derived classes. Attributes: volume (float): volume of the periodic unit cell filepath (str): path to the calculation output files energy (float): DFT total energy in eV xc (str): XC functional used to calculate the total energy. Options are \"hse06\" or \"pbesol\". NAtoms (int): number of atoms in the periodice unit cell Returns: None. \"\"\" self . volume = None self . filepath = None self . energy = None self . xc = None self . NAtoms = None","title":"__init__()"},{"location":"api/#thermopot.calculations.Calculation.check_attributes","text":"Check that the Calculation class attributes make basic sense. Source code in thermopot/calculations.py 27 28 29 30 31 32 33 34 35 36 37 38 def check_attributes ( self ): \"\"\"Check that the Calculation class attributes make basic sense.\"\"\" assert type ( self . filepath ) == str , \"filepath must be a string\" assert type ( self . energy ) == float , \"energy must be a float\" assert type ( self . xc ) == str , \"xc must be a string\" assert ( type ( self . NAtoms ) == int ) and self . NAtoms >= 1 , \"NAtoms must be an integer >= 1\" assert ( type ( self . volume ) == float ) and self . volume > 0 , \"volume must be a float > 0\" Bases: Calculation Class for parsing and storing data from a FHI-AIMS total energy calculation. Source code in thermopot/calculations.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class AimsCalculation ( Calculation ): \"\"\"Class for parsing and storing data from a FHI-AIMS total energy calculation.\"\"\" def __init__ ( self , filepath = \"./calculation.out\" ): \"\"\" Args: filepath: path to the calculation output files \"\"\" super () . __init__ () self . filepath = filepath self . volume = self . get_volume () self . energy = self . get_energy () self . xc = self . get_xc () self . NAtoms = self . get_NAtoms () def get_volume ( self ): with open ( self . filepath ) as contents : return float ( re . findall ( \"Unit cell volume\\s+:\\s*(.*)\\sA\" , contents . read ())[ - 1 ] ) def get_energy ( self ): with open ( self . filepath ) as contents : return float ( re . findall ( \"Total energy of the DFT[^0-9]+(-\\d*\\.?\\d*) eV\" , contents . read () )[ - 1 ] ) def get_xc ( self ): with open ( self . filepath ) as contents : return re . findall ( \"xc\\s+(\\S+)\" , contents . read ())[ - 1 ] def get_NAtoms ( self ): with open ( self . filepath ) as contents : return int ( re . findall ( \"Number of atoms\\s +:\\s + (\\S+)\" , contents . read ())[ - 1 ] )","title":"check_attributes()"},{"location":"api/#thermopot.calculations.AimsCalculation.__init__","text":"Parameters: Name Type Description Default filepath path to the calculation output files './calculation.out' Source code in thermopot/calculations.py 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , filepath = \"./calculation.out\" ): \"\"\" Args: filepath: path to the calculation output files \"\"\" super () . __init__ () self . filepath = filepath self . volume = self . get_volume () self . energy = self . get_energy () self . xc = self . get_xc () self . NAtoms = self . get_NAtoms () Bases: object Parent class for materials properties. See docstrings for derived classes solid, ideal_gas Source code in thermopot/materials.py 20 21 22 23 24 25 26 27 28 29 class Material ( object ): \"\"\"Parent class for materials properties. See docstrings for derived classes solid, ideal_gas\"\"\" def __init__ ( self , name , stoichiometry , energies ): self . name = name self . stoichiometry = stoichiometry self . energies = energies self . N = sum ( self . stoichiometry . values ()) Bases: Material Class for solid material data.","title":"__init__()"},{"location":"api/#thermopot.materials.Solid--sets-properties","text":"solid.name (Identifying string) solid.stoichiometry (Dict relating element to number of atoms in a single formula unit) solid.energies (Dict relating xc functional to DFT total energy in eV) solid.fu_cell (Number of formula units in periodic unit cell) solid.volume (Volume of unit cell in cubic angstroms (m3 * 10^30)) solid.phonons (String containing path to phonopy-FHI-aims output data file) solid.N (Number of atoms per formula unit) solid.NAtoms (Number of atoms in periodic unit cell)","title":"Sets properties:"},{"location":"api/#thermopot.materials.Solid--sets-methods","text":"solid.U_eV(T), solid.U_J(T), solid.U_kJ(T) : Internal energy solid.H_eV(T,P), solid.H_J(T,P), solid.H_kJ(T,P) : Enthalpy H = U + PV solid.mu_eV(T,P), solid.mu_J(T,P), solid.mu_kJ(T,P) : Chemical potential mu = U + PV - TS The material is assumed to be incompressible and without thermal expansion Source code in thermopot/materials.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 class Solid ( Material ): \"\"\" Class for solid material data. Sets properties: ------------------- solid.name (Identifying string) solid.stoichiometry (Dict relating element to number of atoms in a single formula unit) solid.energies (Dict relating xc functional to DFT total energy in eV) solid.fu_cell (Number of formula units in periodic unit cell) solid.volume (Volume of unit cell in cubic angstroms (m3 * 10^30)) solid.phonons (String containing path to phonopy-FHI-aims output data file) solid.N (Number of atoms per formula unit) solid.NAtoms (Number of atoms in periodic unit cell) Sets methods: ------------------- solid.U_eV(T), solid.U_J(T), solid.U_kJ(T) : Internal energy solid.H_eV(T,P), solid.H_J(T,P), solid.H_kJ(T,P) : Enthalpy H = U + PV solid.mu_eV(T,P), solid.mu_J(T,P), solid.mu_kJ(T,P) : Chemical potential mu = U + PV - TS The material is assumed to be incompressible and without thermal expansion \"\"\" def __init__ ( self , name , stoichiometry , phonon_filepath , calculation = False , volume = False , energies = False , NAtoms = 1 , ): if calculation is not False : Material . __init__ ( self , name , stoichiometry , { calculation . xc : calculation . energy } ) self . volume = calculation . volume self . NAtoms = calculation . NAtoms else : Material . __init__ ( self , name , stoichiometry , energies ) self . NAtoms = NAtoms self . volume = volume self . fu_cell = self . NAtoms / self . N self . phonons = materials_directory + phonon_filepath # TODO: allow calculations without giving phonons def U_eV ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one formula unit of solid, expressed in eV. U = solid.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" U_func = interpolate . get_potential_aims ( self . phonons , \"U\" ) E_dft = self . energies [ xc ] return ( E_dft + U_func ( T )) / self . fu_cell def U_J ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of solid, expressed in J/mol U = solid.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return ( self . U_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def U_kJ ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of solid, expressed in kJ/mol U = solid.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return self . U_J ( T , xc = xc ) / 1000.0 def H_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Enthalpy of one formula unit of solid, expressed in eV H = solid.H_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" U_func = interpolate . get_potential_aims ( self . phonons , \"U\" ) PV = ( P * self . volume * 1e-30 * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) E_dft = self . energies [ xc ] return (( E_dft + U_func ( T )) + PV ) / self . fu_cell def H_J ( self , T , P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of solid, expressed in J/mol H = solid.H_J(T,P) T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . H_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def H_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of solid, expressed in kJ/mol H = solid.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . H_J ( T , P , xc = xc ) * 0.001 def mu_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one formula unit of solid, expressed in eV mu = solid.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" TS_func = interpolate . get_potential_aims ( self . phonons , \"TS\" ) H = self . H_eV ( T , P , xc = xc ) return H - TS_func ( T ) / self . fu_cell def mu_J ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of solid, expressed in J/mol mu = solid.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . mu_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def mu_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of solid, expressed in kJ/mol mu = solid.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . mu_J ( T , P , xc = xc ) * 0.001 def Cv_kB ( self , T ): \"\"\" Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_kB(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" Cv_func = interpolate . get_potential_aims ( self . phonons , \"Cv\" ) return Cv_func ( T ) / self . fu_cell def Cv_eV ( self , T ): \"\"\" Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_eV(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return ( self . Cv_kB ( T ) * constants . physical_constants [ \"Boltzmann constant in eV/K\" ][ 0 ] ) def Cv_J ( self , T ): \"\"\" Constant-volume heat capacity of solid, expressed in J/molK. Cv = solid.Cv_J(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return ( self . Cv_kB ( T ) * constants . physical_constants [ \"Boltzmann constant\" ][ 0 ] * constants . N_A ) def Cv_kJ ( self , T ): \"\"\" Constant-volume heat capacity of solid, expressed in kJ/molK. Cv = solid.Cv_kJ(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return self . Cv_J ( T ) * 0.001","title":"Sets methods:"},{"location":"api/#thermopot.materials.Solid.Cv_J","text":"Constant-volume heat capacity of solid, expressed in J/molK. Cv = solid.Cv_J(T) T may be an array, in which case Cv will be an array of the same dimensions. Source code in thermopot/materials.py 268 269 270 271 272 273 274 275 276 277 278 def Cv_J ( self , T ): \"\"\" Constant-volume heat capacity of solid, expressed in J/molK. Cv = solid.Cv_J(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return ( self . Cv_kB ( T ) * constants . physical_constants [ \"Boltzmann constant\" ][ 0 ] * constants . N_A )","title":"Cv_J()"},{"location":"api/#thermopot.materials.Solid.Cv_eV","text":"Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_eV(T) T may be an array, in which case Cv will be an array of the same dimensions. Source code in thermopot/materials.py 256 257 258 259 260 261 262 263 264 265 266 def Cv_eV ( self , T ): \"\"\" Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_eV(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return ( self . Cv_kB ( T ) * constants . physical_constants [ \"Boltzmann constant in eV/K\" ][ 0 ] )","title":"Cv_eV()"},{"location":"api/#thermopot.materials.Solid.Cv_kB","text":"Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_kB(T) T may be an array, in which case Cv will be an array of the same dimensions. Source code in thermopot/materials.py 246 247 248 249 250 251 252 253 254 def Cv_kB ( self , T ): \"\"\" Constant-volume heat capacity of one formula unit of solid, expressed in units of the Boltzmann constant kB: Cv = solid.Cv_kB(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" Cv_func = interpolate . get_potential_aims ( self . phonons , \"Cv\" ) return Cv_func ( T ) / self . fu_cell","title":"Cv_kB()"},{"location":"api/#thermopot.materials.Solid.Cv_kJ","text":"Constant-volume heat capacity of solid, expressed in kJ/molK. Cv = solid.Cv_kJ(T) T may be an array, in which case Cv will be an array of the same dimensions. Source code in thermopot/materials.py 280 281 282 283 284 285 286 def Cv_kJ ( self , T ): \"\"\" Constant-volume heat capacity of solid, expressed in kJ/molK. Cv = solid.Cv_kJ(T) T may be an array, in which case Cv will be an array of the same dimensions. \"\"\" return self . Cv_J ( T ) * 0.001","title":"Cv_kJ()"},{"location":"api/#thermopot.materials.Solid.H_J","text":"Enthalpy of one gram-mole of solid, expressed in J/mol H = solid.H_J(T,P) T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def H_J ( self , T , P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of solid, expressed in J/mol H = solid.H_J(T,P) T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . H_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A )","title":"H_J()"},{"location":"api/#thermopot.materials.Solid.H_eV","text":"Enthalpy of one formula unit of solid, expressed in eV H = solid.H_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def H_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Enthalpy of one formula unit of solid, expressed in eV H = solid.H_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" U_func = interpolate . get_potential_aims ( self . phonons , \"U\" ) PV = ( P * self . volume * 1e-30 * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) E_dft = self . energies [ xc ] return (( E_dft + U_func ( T )) + PV ) / self . fu_cell","title":"H_eV()"},{"location":"api/#thermopot.materials.Solid.H_kJ","text":"Enthalpy of one gram-mole of solid, expressed in kJ/mol H = solid.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def H_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of solid, expressed in kJ/mol H = solid.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . H_J ( T , P , xc = xc ) * 0.001","title":"H_kJ()"},{"location":"api/#thermopot.materials.Solid.U_J","text":"Internal energy of one gram-mole of solid, expressed in J/mol U = solid.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 97 98 99 100 101 102 103 104 105 106 107 108 109 def U_J ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of solid, expressed in J/mol U = solid.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return ( self . U_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A )","title":"U_J()"},{"location":"api/#thermopot.materials.Solid.U_eV","text":"Internal energy of one formula unit of solid, expressed in eV. U = solid.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 85 86 87 88 89 90 91 92 93 94 95 def U_eV ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one formula unit of solid, expressed in eV. U = solid.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" U_func = interpolate . get_potential_aims ( self . phonons , \"U\" ) E_dft = self . energies [ xc ] return ( E_dft + U_func ( T )) / self . fu_cell","title":"U_eV()"},{"location":"api/#thermopot.materials.Solid.U_kJ","text":"Internal energy of one gram-mole of solid, expressed in kJ/mol U = solid.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 111 112 113 114 115 116 117 118 119 def U_kJ ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of solid, expressed in kJ/mol U = solid.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return self . U_J ( T , xc = xc ) / 1000.0","title":"U_kJ()"},{"location":"api/#thermopot.materials.Solid.mu_J","text":"Free energy of one mol of solid, expressed in J/mol mu = solid.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def mu_J ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of solid, expressed in J/mol mu = solid.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . mu_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A )","title":"mu_J()"},{"location":"api/#thermopot.materials.Solid.mu_eV","text":"Free energy of one formula unit of solid, expressed in eV mu = solid.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def mu_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one formula unit of solid, expressed in eV mu = solid.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" TS_func = interpolate . get_potential_aims ( self . phonons , \"TS\" ) H = self . H_eV ( T , P , xc = xc ) return H - TS_func ( T ) / self . fu_cell","title":"mu_eV()"},{"location":"api/#thermopot.materials.Solid.mu_kJ","text":"Free energy of one mol of solid, expressed in kJ/mol mu = solid.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def mu_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of solid, expressed in kJ/mol mu = solid.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . mu_J ( T , P , xc = xc ) * 0.001 Bases: Material Class for ideal gas properties.","title":"mu_kJ()"},{"location":"api/#thermopot.materials.IdealGas--sets-properties","text":"ideal_gas.name (string) ideal_gas.stoichiometry (Dict relating element to number of atoms in a single formula unit) ideal_gas.energies (Dict relating xc functional with DFT total energy) ideal_gas.thermo_data (String containing path to aims.vibrations output data file) ideal_gas.N (Number of atoms per formula unit)","title":"Sets properties:"},{"location":"api/#thermopot.materials.IdealGas--sets-methods","text":"ideal_gas.U_eV(T), ideal_gas.U_J(T), ideal_gas.U_kJ(T) : Internal energy ideal_gas.H_eV(T), ideal_gas.H_J(T), ideal_gas.H_kJ(T) : Enthalpy H = U + PV ideal_gas.mu_eV(T,P), ideal_gas.mu_J(T,P), ideal_gas.mu_kJ(T,P) : Chemical potential mu = U + PV - TS Ideal gas law PV=nRT is applied: specifically (dH/dP) at const. T = 0 and int(mu)^P2_P1 dP = kTln(P2/P1) Enthalpy has no P dependence as volume is not restricted / expansion step is defined as isothermal Source code in thermopot/materials.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 class IdealGas ( Material ): \"\"\" Class for ideal gas properties. Sets properties: ------------------- ideal_gas.name (string) ideal_gas.stoichiometry (Dict relating element to number of atoms in a single formula unit) ideal_gas.energies (Dict relating xc functional with DFT total energy) ideal_gas.thermo_data (String containing path to aims.vibrations output data file) ideal_gas.N (Number of atoms per formula unit) Sets methods: ------------------- ideal_gas.U_eV(T), ideal_gas.U_J(T), ideal_gas.U_kJ(T) : Internal energy ideal_gas.H_eV(T), ideal_gas.H_J(T), ideal_gas.H_kJ(T) : Enthalpy H = U + PV ideal_gas.mu_eV(T,P), ideal_gas.mu_J(T,P), ideal_gas.mu_kJ(T,P) : Chemical potential mu = U + PV - TS Ideal gas law PV=nRT is applied: specifically (dH/dP) at const. T = 0 and int(mu)^P2_P1 dP = kTln(P2/P1) Enthalpy has no P dependence as volume is not restricted / expansion step is defined as isothermal \"\"\" # TODO:script for calculating zpe values def __init__ ( self , name , stoichiometry , thermo_file , calculation = False , energies = False , zpe_pbesol = 0 , zpe_hse06 = 0 , zpe_lit = 0 , ): if calculation is not False : Material . __init__ ( self , name , stoichiometry , { calculation . xc : calculation . energy } ) else : Material . __init__ ( self , name , stoichiometry , energies ) self . thermo_file = materials_directory + thermo_file # Initialise ZPE to HSE06 value if provided. # This looks redundant at the moment: the intent is to implement # some kind of switch or heirarchy of methods further down the line. if zpe_hse06 > 0 : self . zpe = zpe_pbesol elif zpe_pbesol > 0 : self . zpe = zpe_pbesol elif zpe_lit > 0 : self . zpe = zpe_lit else : self . zpe = 0 def U_eV ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one formula unit of ideal gas, expressed in eV. U = ideal_gas.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" U_func = interpolate . get_potential_nist_table ( self . thermo_file , \"U\" ) E_dft = self . energies [ xc ] return ( E_dft + self . zpe + U_func ( T ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) def U_J ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of ideal gas, expressed in J/mol U = ideal_gas.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return ( self . U_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def U_kJ ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of ideal gas, expressed in kJ/mol U = ideal_gas.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return self . U_J ( T , xc = xc ) * 0.001 def H_eV ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one formula unit of ideal gas, expressed in eV H = ideal_gas.H_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" H_func = interpolate . get_potential_nist_table ( self . thermo_file , \"H\" ) E_dft = self . energies [ xc ] return ( E_dft + self . zpe + H_func ( T , xc = xc ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) def H_J ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of ideal gas, expressed in J/mol H = ideal_gas.H_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" return ( self . H_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def H_kJ ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of ideal gas, expressed in kJ/mol H = ideal_gas.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" return self . H_J ( T , xc = xc ) * 0.001 def mu_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one formula unit of ideal gas, expressed in eV mu = ideal_gas.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" S_func = interpolate . get_potential_nist_table ( self . thermo_file , \"S\" ) S = ( S_func ( T ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) H = self . H_eV ( T , xc = xc ) return ( H - T * S + constants . physical_constants [ \"Boltzmann constant in eV/K\" ][ 0 ] * T * np . log ( P / 1e5 ) ) def mu_J ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of ideal gas, expressed in J/mol mu = ideal_gas.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . mu_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A ) def mu_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of ideal gas, expressed in kJ/mol mu = ideal_gas.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . mu_J ( T , P , xc = xc ) * 0.001","title":"Sets methods:"},{"location":"api/#thermopot.materials.IdealGas.H_J","text":"Enthalpy of one gram-mole of ideal gas, expressed in J/mol H = ideal_gas.H_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused Source code in thermopot/materials.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 def H_J ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of ideal gas, expressed in J/mol H = ideal_gas.H_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" return ( self . H_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A )","title":"H_J()"},{"location":"api/#thermopot.materials.IdealGas.H_eV","text":"Enthalpy of one formula unit of ideal gas, expressed in eV H = ideal_gas.H_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused Source code in thermopot/materials.py 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def H_eV ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one formula unit of ideal gas, expressed in eV H = ideal_gas.H_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" H_func = interpolate . get_potential_nist_table ( self . thermo_file , \"H\" ) E_dft = self . energies [ xc ] return ( E_dft + self . zpe + H_func ( T , xc = xc ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A )","title":"H_eV()"},{"location":"api/#thermopot.materials.IdealGas.H_kJ","text":"Enthalpy of one gram-mole of ideal gas, expressed in kJ/mol H = ideal_gas.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused Source code in thermopot/materials.py 428 429 430 431 432 433 434 435 436 437 438 439 def H_kJ ( self , T , * P , xc = \"pbesol\" ): \"\"\"Enthalpy of one gram-mole of ideal gas, expressed in kJ/mol H = ideal_gas.H_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns an array with the same dimensions as T Accepts ideal_gas.H_eV(T,P): P is unused \"\"\" return self . H_J ( T , xc = xc ) * 0.001","title":"H_kJ()"},{"location":"api/#thermopot.materials.IdealGas.U_J","text":"Internal energy of one gram-mole of ideal gas, expressed in J/mol U = ideal_gas.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def U_J ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of ideal gas, expressed in J/mol U = ideal_gas.U_J(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return ( self . U_eV ( T , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A )","title":"U_J()"},{"location":"api/#thermopot.materials.IdealGas.U_eV","text":"Internal energy of one formula unit of ideal gas, expressed in eV. U = ideal_gas.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def U_eV ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one formula unit of ideal gas, expressed in eV. U = ideal_gas.U_eV(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" U_func = interpolate . get_potential_nist_table ( self . thermo_file , \"U\" ) E_dft = self . energies [ xc ] return ( E_dft + self . zpe + U_func ( T ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A )","title":"U_eV()"},{"location":"api/#thermopot.materials.IdealGas.U_kJ","text":"Internal energy of one gram-mole of ideal gas, expressed in kJ/mol U = ideal_gas.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . Returns a matrix with the same dimensions as T Source code in thermopot/materials.py 379 380 381 382 383 384 385 386 387 388 def U_kJ ( self , T , xc = \"pbesol\" ): \"\"\"Internal energy of one gram-mole of ideal gas, expressed in kJ/mol U = ideal_gas.U_kJ(T) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. Returns a matrix with the same dimensions as T \"\"\" return self . U_J ( T , xc = xc ) * 0.001","title":"U_kJ()"},{"location":"api/#thermopot.materials.IdealGas.mu_J","text":"Free energy of one mol of ideal gas, expressed in J/mol mu = ideal_gas.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def mu_J ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of ideal gas, expressed in J/mol mu = ideal_gas.mu_J(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return ( self . mu_eV ( T , P , xc = xc ) * constants . physical_constants [ \"electron volt-joule relationship\" ][ 0 ] * constants . N_A )","title":"mu_J()"},{"location":"api/#thermopot.materials.IdealGas.mu_eV","text":"Free energy of one formula unit of ideal gas, expressed in eV mu = ideal_gas.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def mu_eV ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one formula unit of ideal gas, expressed in eV mu = ideal_gas.mu_eV(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" S_func = interpolate . get_potential_nist_table ( self . thermo_file , \"S\" ) S = ( S_func ( T ) * constants . physical_constants [ \"joule-electron volt relationship\" ][ 0 ] / constants . N_A ) H = self . H_eV ( T , xc = xc ) return ( H - T * S + constants . physical_constants [ \"Boltzmann constant in eV/K\" ][ 0 ] * T * np . log ( P / 1e5 ) )","title":"mu_eV()"},{"location":"api/#thermopot.materials.IdealGas.mu_kJ","text":"Free energy of one mol of ideal gas, expressed in kJ/mol mu = ideal_gas.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to pbesol . T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. Source code in thermopot/materials.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def mu_kJ ( self , T , P , xc = \"pbesol\" ): \"\"\" Free energy of one mol of ideal gas, expressed in kJ/mol mu = ideal_gas.mu_kJ(T,P) The xc keyword specifies the DFT XC functional used to calculate the ground state energy. If not specified, it defaults to `pbesol`. T, P may be orthogonal 2D arrays of length m and n, populated in one row/column: in this case H is an m x n matrix. T, P may instead be equal-length non-orthogonal 1D arrays, in which case H is a vector of H values corresponding to T,P pairs. Other T, P arrays may result in undefined behaviour. \"\"\" return self . mu_J ( T , P , xc = xc ) * 0.001 Bases: object Class for calculated sulfur equilibria.","title":"mu_kJ()"},{"location":"api/#thermopot.materials.SulfurModel--sets-properties","text":"sulfur_model.name (string) sulfur_model.pbesol_energy_eV (DFT total energy in eV with PBEsol XC functional for D4d S8 cluster) sulfur_model.thermo_data (String containing path to T/P effects data file) sulfur_model.N (Number of atoms per formula unit) sulfur_model.N_ref (Number of atoms per formula unit of reference state)","title":"Sets properties:"},{"location":"api/#thermopot.materials.SulfurModel--sets-methods","text":"sulfur_model.mu_eV(T,P), sulfur_model.mu_J(T,P), sulfur_model.mu_kJ(T,P) : Chemical potential mu = U + PV - TS Ideal gas law PV=nRT is applied: specifically (dH/dP) at const. T = 0 and int(mu)^P2_P1 dP = kTln(P2/P1) Methods not yet implemented: sulfur_model.U_eV(T), sulfur_model.U_J(T), sulfur_model.U_kJ(T) : Internal energy sulfur_model.H_eV(T), sulfur_model.H_J(T), sulfur_model.H_kJ(T) : Enthalpy H = U + PV","title":"Sets methods:"},{"location":"api/#thermopot.materials.SulfurModel--thermo-data-file-format","text":"CSV file containing header line:","title":"Thermo data file format:"},{"location":"api/#thermopot.materials.SulfurModel--tk-mu-x1-pa-j-mol-1mu-x2-pa-j-mol-1","text":"followed by comma-separated data rows t1,mu11,mu12 ... t2,mu21,mu22 ... ...","title":"T/K, mu (x1 Pa) / J mol-1,mu (x2 Pa) / J mol-1..."},{"location":"api/#thermopot.materials.SulfurModel--dev-note","text":"Not currently a derived class of \"material\" due to substantially different operation. Source code in thermopot/materials.py 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 class SulfurModel ( object ): \"\"\" Class for calculated sulfur equilibria. Sets properties: ------------------- sulfur_model.name (string) sulfur_model.pbesol_energy_eV (DFT total energy in eV with PBEsol XC functional for D4d S8 cluster) sulfur_model.thermo_data (String containing path to T/P effects data file) sulfur_model.N (Number of atoms per formula unit) sulfur_model.N_ref (Number of atoms per formula unit of reference state) Sets methods: ------------------- sulfur_model.mu_eV(T,P), sulfur_model.mu_J(T,P), sulfur_model.mu_kJ(T,P) : Chemical potential mu = U + PV - TS Ideal gas law PV=nRT is applied: specifically (dH/dP) at const. T = 0 and int(mu)^P2_P1 dP = kTln(P2/P1) Methods not yet implemented: ---------------------------- sulfur_model.U_eV(T), sulfur_model.U_J(T), sulfur_model.U_kJ(T) : Internal energy sulfur_model.H_eV(T), sulfur_model.H_J(T), sulfur_model.H_kJ(T) : Enthalpy H = U + PV Thermo data file format: ------------------------ CSV file containing header line: # T/K, mu (x1 Pa) / J mol-1,mu (x2 Pa) / J mol-1... followed by comma-separated data rows t1,mu11,mu12 ... t2,mu21,mu22 ... ... DEV NOTE: --------- Not currently a derived class of \"material\" due to substantially different operation. \"\"\" # TODO: generalise this for other nist data? def __init__ ( self , name , pbesol_energy_eV , mu_file , N = 1 , N_ref = 8 ): self . name = name self . stoichiometry = { \"S\" : 1 } self . pbesol_energy_eV = pbesol_energy_eV self . mu_file = materials_directory + mu_file self . N = 1 self . N_ref = N_ref self . _mu_tab = interpolate . get_potential_sulfur_table ( self . mu_file ) def mu_J ( self , T , P ): if type ( T ) == np . ndarray : T = T . flatten () if type ( P ) == np . ndarray : P = P . flatten () E0 = self . pbesol_energy_eV * eV2Jmol return self . _mu_tab ( T , P ) + E0 / self . N_ref def mu_kJ ( self , T , P ): return self . mu_J ( T , P ) * 1e-3 def mu_eV ( self , T , P ): return self . mu_J ( T , P ) / eV2Jmol Class for reaction data","title":"DEV NOTE:"},{"location":"api/#thermopot.reactions.Reaction--sets-properties","text":"reaction.reactants (Dict relating reactant materials to a number of formula units) reaction.products (Dict relating product materials to a number of formular units)","title":"Sets properties:"},{"location":"api/#thermopot.reactions.Reaction--sets-methods","text":"reaction.DH_eV_pbesol(T,P), reaction.DH_kJ_pbesol(T,P), reaction.DH_eV_hse06(T,P), reaction.DH_kJ_hse06(T,P) : Enthalpy of formation reaction.DU_eV_pbesol(T,P), reaction.DU_kJ_pbesol(T,P), reaction.DU_eV_hse06(T,P), reaction.DU_kJ_hse06(T,P) : Internal energy change reaction.Dmu_eV_pbesol(T,P), reaction.Dmu_kJ_pbesol(T,P), reaction.Dmu_eV_hse06(T,P), reaction.Dmu_kJ_hse06(T,P) : Gibbs free energy of formation Source code in thermopot/reactions.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class Reaction : \"\"\" Class for reaction data Sets properties: ------------------- reaction.reactants (Dict relating reactant materials to a number of formula units) reaction.products (Dict relating product materials to a number of formular units) Sets methods: ------------------- reaction.DH_eV_pbesol(T,P), reaction.DH_kJ_pbesol(T,P), reaction.DH_eV_hse06(T,P), reaction.DH_kJ_hse06(T,P) : Enthalpy of formation reaction.DU_eV_pbesol(T,P), reaction.DU_kJ_pbesol(T,P), reaction.DU_eV_hse06(T,P), reaction.DU_kJ_hse06(T,P) : Internal energy change reaction.Dmu_eV_pbesol(T,P), reaction.Dmu_kJ_pbesol(T,P), reaction.Dmu_eV_hse06(T,P), reaction.Dmu_kJ_hse06(T,P) : Gibbs free energy of formation \"\"\" def __init__ ( self , reactants_dictionary , products_dictionary , temperature = 298.15 , pressure = 1e5 , ): \"\"\" reactants_dictionary and products dictionary takes the form { class_instance : formula units } and can have an arbitrary number of key-value pairs. `Class instance` is an instance of the `materials.solid` or `materials.ideal_gas` classes. temperature is provided in kelvin, pressure is provided in Pa. \"\"\" self . reactants = reactants_dictionary self . products = products_dictionary self . T = temperature self . P = pressure def DH_eV_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_enthalpy , products_enthalpy = 0 , 0 for material , fu in self . reactants . items (): reactants_enthalpy += material . H_eV ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_enthalpy += material . H_eV ( T , P , xc = \"pbesol\" ) * fu return products_enthalpy - reactants_enthalpy def DH_kJ_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_enthalpy , products_enthalpy = 0 , 0 for material , fu in self . reactants . items (): reactants_enthalpy += material . H_kJ ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_enthalpy += material . H_kJ ( T , P , xc = \"pbesol\" ) * fu return products_enthalpy - reactants_enthalpy def DH_eV_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_enthalpy , products_enthalpy = 0 , 0 for material , fu in self . reactants . items (): reactants_enthalpy += material . H_eV ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_enthalpy += material . H_eV ( T , P , xc = \"hse06\" ) * fu return products_enthalpy - reactants_enthalpy def DH_kJ_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_enthalpy , products_enthalpy = 0 , 0 for material , fu in self . reactants . items (): reactants_enthalpy += material . H_kJ ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_enthalpy += material . H_kJ ( T , P , xc = \"hse06\" ) * fu return products_enthalpy - reactants_enthalpy def DU_eV_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . U_eV ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_energy += material . U_eV ( T , P , xc = \"pbesol\" ) * fu return products_energy - reactants_energy def DU_kJ_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . U_kJ ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_energy += material . U_kJ ( T , P , xc = \"pbesol\" ) * fu return products_energy - reactants_energy def DU_eV_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . U_eV ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_energy += material . U_eV ( T , P , xc = \"hse06\" ) * fu return products_energy - reactants_energy def DU_kJ_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . U_kJ ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_energy += material . U_kJ ( T , P , xc = \"hse06\" ) * fu return products_energy - reactants_energy def Dmu_eV_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . mu_eV ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_energy += material . mu_eV ( T , P , xc = \"pbesol\" ) * fu return products_energy - reactants_energy def Dmu_kJ_pbesol ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . mu_kJ ( T , P , xc = \"pbesol\" ) * fu for material , fu in self . products . items (): products_energy += material . mu_kJ ( T , P , xc = \"pbesol\" ) * fu return products_energy - reactants_energy def Dmu_eV_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . mu_eV ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_energy += material . mu_eV ( T , P , xc = \"hse06\" ) * fu return products_energy - reactants_energy def Dmu_kJ_hse06 ( self , T = None , P = None ): T = self . T if T is None else T P = self . P if P is None else P reactants_energy , products_energy = 0 , 0 for material , fu in self . reactants . items (): reactants_energy += material . mu_kJ ( T , P , xc = \"hse06\" ) * fu for material , fu in self . products . items (): products_energy += material . mu_kJ ( T , P , xc = \"hse06\" ) * fu return products_energy - reactants_energy","title":"Sets methods:"},{"location":"api/#thermopot.reactions.Reaction.__init__","text":"reactants_dictionary and products dictionary takes the form { class_instance : formula units } and can have an arbitrary number of key-value pairs. Class instance is an instance of the materials.solid or materials.ideal_gas classes. temperature is provided in kelvin, pressure is provided in Pa. Source code in thermopot/reactions.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def __init__ ( self , reactants_dictionary , products_dictionary , temperature = 298.15 , pressure = 1e5 , ): \"\"\" reactants_dictionary and products dictionary takes the form { class_instance : formula units } and can have an arbitrary number of key-value pairs. `Class instance` is an instance of the `materials.solid` or `materials.ideal_gas` classes. temperature is provided in kelvin, pressure is provided in Pa. \"\"\" self . reactants = reactants_dictionary self . products = products_dictionary self . T = temperature self . P = pressure Thermodynamic property interpolation function. Requires phonopy-FHI-aims output file. Reads data for S and Cv expressed in J/K/mol, F and U in kJ/mol. Outputs data for S and Cv in kB/cell, U, F and TS in eV/cell. Source code in thermopot/interpolate.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def get_potential_aims ( file , property ): \"\"\"Thermodynamic property interpolation function. Requires phonopy-FHI-aims output file. Reads data for S and Cv expressed in J/K/mol, F and U in kJ/mol. Outputs data for S and Cv in kB/cell, U, F and TS in eV/cell. \"\"\" data = genfromtxt ( file ) T = data [:, 0 ] if property in ( \"Cv\" , \"Cp\" , \"heat_capacity\" , \"C\" ): potential = data [:, 3 ] / kB2JKmol elif property in ( \"U\" , \"internal_energy\" ): potential = data [:, 4 ] / eV2kJmol elif property in ( \"F\" , \"A\" , \"Helmholtz\" , \"free_energy\" ): potential = data [:, 1 ] / eV2kJmol elif property in ( \"S\" , \"Entropy\" , \"entropy\" ): potential = data [:, 2 ] / kB2JKmol elif property in ( \"TS\" ): potential = T * data [:, 2 ] else : raise RuntimeError ( \"Property not found\" ) thefunction = interp1d ( T , potential , kind = \"linear\" ) return thefunction Thermodynamic property interpolation function. Requires NIST-JANAF table. All properties in J, mol and K Source code in thermopot/interpolate.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def get_potential_nist_table ( file , property ): \"\"\"Thermodynamic property interpolation function. Requires NIST-JANAF table. All properties in J, mol and K\"\"\" data = genfromtxt ( file , skip_header = 2 ) T = data [:, 0 ] if property in ( \"Cp\" , \"C\" , \"heat_capacity\" ): potential = data [:, 1 ] elif property in ( \"S\" , \"entropy\" ): potential = data [:, 2 ] elif property in ( \"H\" , \"enthalpy\" ): potential = ( data [:, 4 ] - data [ 0 , 4 ]) * 1e3 elif property in ( \"U\" , \"internal_energy\" ): # U = H - PV; for ideal gas molar PV = RT so U = H - RT from scipy.constants import R as R potential = ( data [:, 4 ] - data [ 0 , 4 ]) * 1e3 - R * data [:, 0 ] elif property in ( \"DH\" , \"Delta_H\" , \"standard_enthalpy_change\" ): potential = data [:, 4 ] * 1e3 else : raise RuntimeError ( \"Property not found\" ) thefunction = interp1d ( T , potential , kind = \"cubic\" ) return thefunction Read thermodynamic property as function of T, P from datafile. Datafile should be generated by the code at http://github.com/WMD-bath/sulfur-model or follow the same format Source code in thermopot/interpolate.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def get_potential_sulfur_table ( filename ): \"\"\" Read thermodynamic property as function of T, P from datafile. Datafile should be generated by the code at http://github.com/WMD-bath/sulfur-model or follow the same format \"\"\" # Import chemical potential in J mol-1 vs T, P from file data = genfromtxt ( filename , comments = \"#\" , delimiter = \",\" ) T = data [:, 0 ] . flatten () with open ( filename , \"r\" ) as f : header = f . readline () P = [ float ( p ) for p in re . findall ( r \"\\d+.\\d+\" , header )] thefunction = interp2d ( T , np . log ( P ), data [:, 1 :] . transpose (), kind = \"cubic\" ) def lin_P_function ( T , P ): return thefunction ( T , np . log ( P )) return lin_P_function T is an array e.g. np.linspace(100, 1500, 100) # K P is an array orthogonal to T. e.g. np.array(np.logspace(1, 7, 100), ndmin=2).transpose() # Pa potential is returned from a reactions.reaction method called for an instance with attributes T,P. If T has length m and P has length n, P will be a 2D array with dimensions m x n. e.g. reactions.reaction({Ba:1,S:2}, {BaS2:1}},temperature=T,pressure=P).Dmu_eV_pbesol() potential_label is the label of the contour colorbar e.g. '$\\Delta G_f$ / kJ mol$^{-1}$' scale_range is the scale of the colorbar e.g. [-380, -240] filename is the output filename e.g. 'plots/Dmu-BaS2-Ba-S2.png'. If not provided plt.show() is called. Source code in thermopot/plots.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def plot_TvsP ( T , P , * potential , potential_label = \"$\\Delta G_f$ / kJ mol$^{-1}$\" , scale_range = [ - 600 , 0 ], filename = False , precision = \" %d \" , T_units = \"K\" , P_units = \"Pa\" ): \"\"\" T is an array e.g. np.linspace(100, 1500, 100) # K P is an array orthogonal to T. e.g. np.array(np.logspace(1, 7, 100), ndmin=2).transpose() # Pa potential is returned from a reactions.reaction method called for an instance with attributes T,P. If T has length m and P has length n, P will be a 2D array with dimensions m x n. e.g. reactions.reaction({Ba:1,S:2}, {BaS2:1}},temperature=T,pressure=P).Dmu_eV_pbesol() potential_label is the label of the contour colorbar e.g. '$\\Delta G_f$ / kJ mol$^{-1}$' scale_range is the scale of the colorbar e.g. [-380, -240] filename is the output filename e.g. 'plots/Dmu-BaS2-Ba-S2.png'. If not provided `plt.show()` is called. \"\"\" mpl . rcParams [ \"font.family\" ] = \"serif\" mpl . rcParams [ \"font.serif\" ] = \"Times New Roman\" mpl . rcParams [ \"font.size\" ] = 16 # Unit conversions (all calculations are in SI units, conversion needed for plots) if T_units == \"K\" : x_values = T x_unitlabel = \"K\" elif T_units == \"C\" : x_values = T - 273.15 x_unitlabel = \"$^\\circ$ C\" else : raise ValueError ( \"Invalid temperature unit: {0} \" . format ( T_units )) if P_units == \"Pa\" : y_values = P . flatten () elif P_units == \"Bar\" or P_units == \"bar\" : y_values = P . flatten () * 1e-5 elif P_units == \"mbar\" : y_values = P . flatten () * 1e-5 * 1e3 elif P_units == \"kPa\" : y_values = P . flatten () * 1e-3 elif P_units == \"mmHg\" or P_units == \"torr\" : y_values = P . flatten () * 760 / ( 1.01325e5 ) else : raise ValueError ( \"Invalid pressure unit: {0} .\" . format ( T_units )) if len ( potential ) == 1 : potential = potential else : find_potentials_minimum ( potential ) fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 ) a = plt . contour ( x_values , y_values , potential , 10 , linewidths = 1 , colors = \"k\" ) plt . pcolormesh ( x_values , y_values , potential , cmap = plt . get_cmap ( \"summer\" ), vmin = scale_range [ 0 ], vmax = scale_range [ 1 ], ) colours = plt . colorbar () plt . xlabel ( \"Temperature / {0} \" . format ( x_unitlabel )) plt . ylabel ( \"Pressure / {0} \" . format ( P_units )) colours . set_label ( potential_label , labelpad = 20 ) ax . set_yscale ( \"log\" ) plt . clabel ( a , fmt = precision ) if filename : plt . savefig ( filename , dpi = 200 ) else : plt . show ()","title":"__init__()"},{"location":"background/","text":"Coming soon...ish \ud83d\udc22","title":"Background"},{"location":"contributing/","text":"Coming soon...ish \ud83d\udc22","title":"Contributing"},{"location":"installation/","text":"Coming soon...ish \ud83d\udc22","title":"Installation"},{"location":"tutorial/","text":"","title":"Tutorial"}]}